/* DONT'T EDIT THIS FILE.
 * THIS IS GENERATED BY "Configure/configure_shader.py".
 */
#ifndef KVS__GLEW__GLSL__StochasticRenderingEngine_H_INCLUDE
#define KVS__GLEW__GLSL__StochasticRenderingEngine_H_INCLUDE

#include <string>

namespace kvs { namespace glew { namespace glsl {

namespace StochasticRenderingEngine
{

namespace Vertex
{

const std::string line =
    "varying vec3 position;\n"
    "varying vec2 id;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "varying float depth;\n"
    "#endif\n"
    "\n"
    "attribute vec2 identifier;\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_Position = ftransform();\n"
    "    gl_FrontColor = gl_Color;\n"
    "\n"
    "    position = ( gl_ModelViewMatrix * gl_Vertex ).xyz;\n"
    "    id = identifier;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    depth = gl_Position.z / gl_Position.w;\n"
    "#endif\n"
    "}\n"
;

const std::string multiple_tetrahedra1 =
    "varying vec4 position_in;\n"
    "varying vec2 id_in;\n"
    "varying float value_in;\n"
    "varying vec3 normal_in;\n"
    "\n"
    "attribute vec2 identifier;\n"
    "attribute float value;\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_Position = ftransform();\n"
    "\n"
    "    position_in = gl_ModelViewMatrix * gl_Vertex;\n"
    "    id_in = identifier;\n"
    "    value_in = value;\n"
    "    normal_in = gl_NormalMatrix * gl_Normal;\n"
    "}\n"
;

const std::string multiple_tetrahedra2 =
    "varying vec4 position_in;\n"
    "varying vec2 id_in;\n"
    "varying float value_in;\n"
    "varying vec3 normal_in;\n"
    "\n"
    "attribute vec2 identifier;\n"
    "attribute float value;\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_Position = ftransform();\n"
    "\n"
    "    position_in = gl_ModelViewMatrix * gl_Vertex;\n"
    "    id_in = identifier;\n"
    "    value_in = value;\n"
    "    normal_in = gl_NormalMatrix * gl_Normal;\n"
    "}\n"
;

const std::string multivariate_tetrahedra =
    "varying vec4 position_in;\n"
    "varying vec2 id_in;\n"
    "varying vec2 value_in;\n"
    "varying vec3 normal_in;\n"
    "\n"
    "attribute vec2 identifier;\n"
    "attribute vec2 value;\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_Position = ftransform();\n"
    "\n"
    "    position_in = gl_ModelViewMatrix * gl_Vertex;\n"
    "    id_in = identifier;\n"
    "    value_in = value;\n"
    "    normal_in = gl_NormalMatrix * gl_Normal;\n"
    "}\n"
;

const std::string point =
    "uniform float densityFactor;\n"
    "uniform int circle_threshold;\n"
    "uniform vec2 screen_scale;\n"
    "uniform sampler2D random_texture;\n"
    "uniform float random_texture_size_inv;\n"
    "uniform vec2 random_offset;\n"
    "attribute vec2 identifier;\n"
    "\n"
    "const float CIRCLE_SCALE = 0.564189583547756; // 1.0 / sqrt(PI)\n"
    "\n"
    "varying vec3  position;\n"
    "varying vec3  normal;\n"
    "varying vec2  center;\n"
    "varying float radius;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "varying float depth;\n"
    "#endif\n"
    "\n"
    "\n"
    "float zooming( in vec4 p )\n"
    "{\n"
    "    // Depth value.\n"
    "    float D = p.z;\n"
    "    if ( D < 1.0 ) D = 1.0; // to avoid front-clip\n"
    "\n"
    "    // Calculate the footprint size of the particle.\n"
    "    float s = densityFactor / D; // footprint size of the particle in pixel\n"
    "    float sf = floor( s );       // round-down value of s\n"
    "    float sc = ceil( s );        // round-up value of s\n"
    "\n"
    "    // Calculate a probability 'pc' that the footprint size is 'sc'.\n"
    "    float fraction = fract( s );\n"
    "    float pc = fraction * ( 2.0 * sf + fraction ) / ( 2.0 * sf + 1.0 );\n"
    "\n"
    "    // Random number from the random number texture.\n"
    "    vec2 random_texture_index = identifier * random_texture_size_inv;\n"
    "    float R = texture2D( random_texture, random_texture_index ).x;\n"
    "\n"
    "    if ( circle_threshold <= 0 || s <= float( circle_threshold ) )\n"
    "    {\n"
    "        // Draw the particle as square.\n"
    "        s = ( ( R < pc ) ? sc : sf );\n"
    "        radius = 0.0;\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        // Draw the particle as circle.\n"
    "        // Convert position to screen coordinates.\n"
    "        center = screen_scale + ( ( p.xy / p.w ) * screen_scale );\n"
    "        radius = ( ( R < pc ) ? sc : sf ) * CIRCLE_SCALE;\n"
    "        s = ceil( s * CIRCLE_SCALE * 2.0 ) + 1.0;\n"
    "    }\n"
    "\n"
    "    return( s );\n"
    "}\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
    "    gl_FrontColor = gl_Color;\n"
    "\n"
    "    position = vec3( gl_ModelViewMatrix * gl_Vertex );\n"
    "    normal = ( gl_NormalMatrix * gl_Normal ).xyz;\n"
    "\n"
    "    gl_PointSize = zooming( gl_Position );\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    depth = gl_Position.z / gl_Position.w;\n"
    "#endif\n"
    "}\n"
;

const std::string polygon =
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "varying vec2 id;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "varying float depth;\n"
    "#endif\n"
    "\n"
    "attribute vec2 identifier;\n"
    "\n"
    "uniform float polygon_offset;\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_Position = ftransform();\n"
    "    gl_Position.z -= polygon_offset;\n"
    "    gl_FrontColor = gl_Color;\n"
    "\n"
    "    position = ( gl_ModelViewMatrix * gl_Vertex ).xyz;\n"
    "    normal = ( gl_NormalMatrix * gl_Normal ).xyz;\n"
    "    id = identifier;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    depth = gl_Position.z / gl_Position.w;\n"
    "#endif\n"
    "}\n"
;

const std::string tetrahedra =
    "varying vec4 position_in;\n"
    "varying vec2 id_in;\n"
    "varying float value_in;\n"
    "varying vec3 normal_in;\n"
    "\n"
    "attribute vec2 identifier;\n"
    "attribute float value;\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_Position = ftransform();\n"
    "\n"
    "    position_in = gl_ModelViewMatrix * gl_Vertex;\n"
    "    id_in = identifier;\n"
    "    value_in = value;\n"
    "    normal_in = gl_NormalMatrix * gl_Normal;\n"
    "}\n"
;

} // end of namespace Vertex

namespace Geometry
{

const std::string multiple_tetrahedra1 =
    "#version 120\n"
    "#extension GL_EXT_geometry_shader4 : enable\n"
    "#extension GL_EXT_gpu_shader4 : enable\n"
    "\n"
    "varying in vec4 position_in[4];\n"
    "varying in float value_in[4];\n"
    "varying in vec2 id_in[4];\n"
    "varying in vec3 normal_in[4];\n"
    "\n"
    "varying out vec3 position;\n"
    "varying out vec3 normal;\n"
    "varying out vec2 id;\n"
    "\n"
    "varying out float depth_front;\n"
    "varying out float depth_back;\n"
    "\n"
    "varying out float scalar_front;\n"
    "varying out float scalar_back;\n"
    "varying out float distance;\n"
    "\n"
    "uniform vec2 preintegration_scale_offset;\n"
    "uniform sampler2D decomposion_texture;\n"
    "\n"
    "vec3 screen_position[4];\n"
    "\n"
    "int direction( in int p0, in int p1, in int p2 )\n"
    "{\n"
    "    vec2 v1 = screen_position[p1].xy - screen_position[p0].xy;\n"
    "    vec2 v2 = screen_position[p2].xy - screen_position[p0].xy;\n"
    "    float cross_product = v1.x * v2.y - v1.y * v2.x;\n"
    "    return( int( sign( cross_product ) + 1.0 ) );\n"
    "}\n"
    "\n"
    "void emitExistPoint( const in int index, const in float dist )\n"
    "{\n"
    "    gl_Position = gl_PositionIn[index];\n"
    "    position    = position_in[index].xyz;\n"
    "    depth_front = gl_PositionIn[index].z / gl_PositionIn[index].w;\n"
    "    depth_back  = depth_front;\n"
    "\n"
    "    normal = normal_in[index].xyz;\n"
    "\n"
    "    scalar_front = value_in[index];\n"
    "    scalar_back  = value_in[index];\n"
    "    distance     = dist;\n"
    "\n"
    "    EmitVertex();\n"
    "}\n"
    "\n"
    "void emitNewPoint(\n"
    "    const in vec4 center_position,\n"
    "    const in vec3 center_position_3D,\n"
    "    const in float center_another_depth,\n"
    "    const in vec3 center_normal_3D,\n"
    "    const in float center_scalar_front,\n"
    "    const in float center_scalar_back,\n"
    "    const in float center_distance )\n"
    "{\n"
    "    gl_Position = center_position;\n"
    "    position    = center_position_3D;\n"
    "    depth_front = center_position.z / center_position.w;\n"
    "    depth_back  = center_another_depth;\n"
    "\n"
    "    normal = center_normal_3D;\n"
    "\n"
    "    scalar_front = center_scalar_front;\n"
    "    scalar_back  = center_scalar_back;\n"
    "    distance     = center_distance;\n"
    "\n"
    "    EmitVertex();\n"
    "}\n"
    "\n"
    "\n"
    "float distance_to_texture_coord( const in float distance )\n"
    "{\n"
    "    return( distance * preintegration_scale_offset.x + preintegration_scale_offset.y );\n"
    "}\n"
    "\n"
    "void calculate_across_triangle_to_line_2D( out float r2, out float r3, in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    vec2 v01 = screen_position[p0].xy - screen_position[p1].xy;\n"
    "    vec2 v21 = screen_position[p2].xy - screen_position[p1].xy;\n"
    "    vec2 v31 = screen_position[p3].xy - screen_position[p1].xy;\n"
    "    float delta = v21.x * v31.y - v31.x * v21.y;\n"
    "    if ( delta == 0 )\n"
    "    {\n"
    "        r2 = r3 = 1.0 / 3.0;\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    float delta_inv = 1.0 / delta;\n"
    "    r2 = delta_inv * (  v31.y * v01.x - v31.x * v01.y );\n"
    "    r3 = delta_inv * ( -v21.y * v01.x + v21.x * v01.y );\n"
    "}\n"
    "\n"
    "float perspective_correct( const in float r, const in float p0z, const in float p1z )\n"
    "{\n"
    "    if ( p0z == p1z ) return r;\n"
    "\n"
    "    float p0z_inv = 1.0 / p0z;\n"
    "    float p1z_inv = 1.0 / p1z;\n"
    "    float pz_inv  = p0z_inv + ( p1z_inv - p0z_inv ) * r;\n"
    "    float pz = 1.0 / pz_inv;\n"
    "\n"
    "    float result = ( pz - p0z ) / ( p1z - p0z );\n"
    "    if ( result < 0.0 ) result = 0.0;\n"
    "    if ( result > 1.0 ) result = 1.0;\n"
    "    return( result );\n"
    "}\n"
    "\n"
    "void perspective_correct_triangle( inout float r2, inout float r3, in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    if ( r2 + r3 <= 0 ) return;\n"
    "    float p1z    = gl_PositionIn[p1].w;\n"
    "    float p2z    = gl_PositionIn[p2].w;\n"
    "    float p3z    = gl_PositionIn[p3].w;\n"
    "    float k_2D   = r2 + r3;\n"
    "    float r23_2D = r3 / k_2D;\n"
    "\n"
    "    float r23_3D = perspective_correct( r23_2D, p2z, p3z );\n"
    "\n"
    "    float p23z = p2z + ( p3z - p2z ) * r23_3D;\n"
    "    float k_3D = perspective_correct( k_2D, p1z, p23z );\n"
    "\n"
    "    r3 = r23_3D * k_3D;\n"
    "    r2 = k_3D - r3;\n"
    "}\n"
    "\n"
    "void perspective_correct_line( inout float r, const in int p0, const in int p1 )\n"
    "{\n"
    "    float p0z  = gl_PositionIn[p0].w;\n"
    "    float p1z  = gl_PositionIn[p1].w;\n"
    "    float r_3D = perspective_correct( r, p0z, p1z );\n"
    "\n"
    "    r = r_3D;\n"
    "}\n"
    "\n"
    "void calculate_across_line_to_line_2D( out float r1, out float r3, in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    vec2 v02 = screen_position[p0].xy - screen_position[p2].xy;\n"
    "    vec2 v01 = screen_position[p0].xy - screen_position[p1].xy;\n"
    "    vec2 v32 = screen_position[p3].xy - screen_position[p2].xy;\n"
    "    float delta = v01.x * v32.y - v32.x * v01.y;\n"
    "    if ( delta == 0 )\n"
    "    {\n"
    "        r1 = r3 = 1.0 / 2.0;\n"
    "        return;\n"
    "    }\n"
    "    float delta_inv = 1.0 / delta;\n"
    "    r1 = delta_inv * (  v32.y * v02.x - v32.x * v02.y );\n"
    "    r3 = delta_inv * ( -v01.y * v02.x + v01.x * v02.y );\n"
    "}\n"
    "\n"
    "void create_type_1( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "   float r2, r3;\n"
    "   calculate_across_triangle_to_line_2D( r2, r3, p0, p1, p2, p3 );\n"
    "   perspective_correct_triangle( r2, r3, p0, p1, p2, p3 );\n"
    "\n"
    "   vec4  p123 = position_in[p1] + ( position_in[p2]  - position_in[p1] ) * r2 + ( position_in[p3] - position_in[p1] ) * r3;\n"
    "   float s123 = value_in[p1] + ( value_in[p2] - value_in[p1] ) * r2 + ( value_in[p3] - value_in[p1] ) * r3;\n"
    "\n"
    "    vec4 center_position;\n"
    "    vec3 center_position_3D;\n"
    "    float center_scalar_front, center_scalar_back; \n"
    "\n"
    "    vec3 n123 = normal_in[p1] + ( normal_in[p2] - normal_in[p1] ) * r2 + ( normal_in[p3] - normal_in[p1] ) * p3;\n"
    "    vec3 center_normal_3D;\n"
    "\n"
    "    float a_depth;\n"
    "\n"
    "   if ( length( p123.z ) < length( position_in[p0].z ) )\n"
    "   {\n"
    "       vec4 tmp = gl_PositionIn[p0];\n"
    "       a_depth = tmp.z / tmp.w;\n"
    "\n"
    "       center_position = gl_ProjectionMatrix * p123;\n"
    "       center_position_3D = p123.xyz;\n"
    "\n"
    "       center_normal_3D = n123.xyz;\n"
    "\n"
    "       center_scalar_front = s123;\n"
    "       center_scalar_back = value_in[p0];\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       vec4 tmp = gl_ProjectionMatrix * p123;\n"
    "       a_depth = tmp.z / tmp.w;\n"
    "\n"
    "       center_position = gl_PositionIn[p0];\n"
    "       center_position_3D = position_in[p0].xyz;\n"
    "\n"
    "       center_normal_3D = normal_in[p0].xyz;\n"
    "\n"
    "       center_scalar_front = value_in[p0];\n"
    "       center_scalar_back = s123;\n"
    "   }\n"
    "\n"
    "   float center_distance = distance_to_texture_coord( length( position_in[p0] - p123 ) );\n"
    "\n"
    "    // p1-p2-C p2-C-p3 C-p3-p1\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    emitExistPoint( p2, 0.0 );\n"
    "    emitNewPoint( center_position, center_position_3D, a_depth, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "    emitExistPoint( p3, 0.0 );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    EndPrimitive();\n"
    "}\n"
    "\n"
    "void create_type_2( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "\n"
    "   float r1, r3;\n"
    "   calculate_across_line_to_line_2D( r1, r3, p0, p1, p2, p3 );\n"
    "   perspective_correct_line( r1, p0, p1 );\n"
    "   perspective_correct_line( r3, p2, p3 );\n"
    "\n"
    "   vec4  p01 = position_in[p0] + ( position_in[p1] - position_in[p0] ) * r1;\n"
    "   float s01 = value_in[p0] + ( value_in[p1] - value_in[p0] ) * r1;\n"
    "\n"
    "   vec4  p23 = position_in[p2] + ( position_in[p3]  - position_in[p2] ) * r3;\n"
    "   float s23 = value_in[p2] + ( value_in[p3] - value_in[p2] ) * r3;\n"
    "\n"
    "   vec4 center_position;\n"
    "   vec3 center_position_3D;\n"
    "   float center_scalar_front, center_scalar_back; \n"
    "\n"
    "   vec3 n01 = normal_in[p0] + ( normal_in[p1] - normal_in[p0] ) * r1;\n"
    "   vec3 n23 = normal_in[p2] + ( normal_in[p3] - normal_in[p2] ) * r3;\n"
    "   vec3 center_normal_3D;\n"
    "\n"
    "    float a_depth;\n"
    "\n"
    "   if ( length( p01.xyz ) < length( p23.xyz ) )\n"
    "   {\n"
    "       vec4 tmp = gl_ProjectionMatrix * p23;\n"
    "       a_depth = tmp.z / tmp.w;\n"
    "\n"
    "       center_position = gl_ProjectionMatrix * p01;\n"
    "       center_position_3D = p01.xyz;\n"
    "\n"
    "       center_normal_3D = n01.xyz;\n"
    "\n"
    "       center_scalar_front = s01;\n"
    "       center_scalar_back = s23;\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       vec4 tmp = gl_ProjectionMatrix * p01;\n"
    "       a_depth = tmp.z / tmp.w;\n"
    "\n"
    "       center_position = gl_ProjectionMatrix * p23;\n"
    "       center_position_3D = p23.xyz;\n"
    "\n"
    "       center_normal_3D = n23.xyz;\n"
    "\n"
    "       center_scalar_front = s23;\n"
    "       center_scalar_back = s01;\n"
    "   }\n"
    "\n"
    "   float center_distance = distance_to_texture_coord( length( p01.z - p23.z ) );\n"
    "\n"
    "    // right half: p0-p2-C, p2-C-p1\n"
    "    emitExistPoint( p0, 0.0 );\n"
    "    emitExistPoint( p2, 0.0 );\n"
    "    emitNewPoint( center_position, center_position_3D, a_depth, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    EndPrimitive();\n"
    "\n"
    "    // left half: p0-p3-C, p3-C-p1\n"
    "    emitExistPoint( p0, 0.0 );\n"
    "    emitExistPoint( p3, 0.0 );\n"
    "    emitNewPoint( center_position, center_position_3D, a_depth, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    EndPrimitive();\n"
    "}\n"
    "\n"
    "void create_type_3( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    create_type_2( p0, p1, p2, p3 );\n"
    "}\n"
    "\n"
    "void create_type_4( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    int pFront, pBack;\n"
    "    if ( position_in[p2].z < position_in[p3].z )\n"
    "    {\n"
    "        pFront = p2;\n"
    "        pBack = p3;\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        pFront = p3;\n"
    "        pBack = p2;\n"
    "    }\n"
    "\n"
    "    float a_depth = gl_PositionIn[pBack].z / gl_PositionIn[pBack].w;\n"
    "\n"
    "    float center_distance = distance_to_texture_coord( length( position_in[pBack] - position_in[pFront] ) );\n"
    "    emitExistPoint( p0, 0.0 );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    emitNewPoint( gl_PositionIn[pFront], position_in[pFront].xyz, a_depth, normal_in[pFront].xyz, value_in[pBack], value_in[pFront], center_distance );\n"
    "    //emitExistPoint( pFront, center_distance );\n"
    "    EndPrimitive();\n"
    "}\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    if ( gl_PositionIn[0].w <= 0 ||\n"
    "         gl_PositionIn[1].w <= 0 ||\n"
    "         gl_PositionIn[2].w <= 0 ||\n"
    "         gl_PositionIn[3].w <= 0 ) return;\n"
    "\n"
    "    screen_position[0] = gl_PositionIn[0].xyz / gl_PositionIn[0].w;\n"
    "    screen_position[1] = gl_PositionIn[1].xyz / gl_PositionIn[1].w;\n"
    "    screen_position[2] = gl_PositionIn[2].xyz / gl_PositionIn[2].w;\n"
    "    screen_position[3] = gl_PositionIn[3].xyz / gl_PositionIn[3].w;\n"
    "\n"
    "    if ( ( screen_position[0].x < -1.0 && screen_position[1].x < -1.0 && screen_position[2].x < -1.0 && screen_position[3].x < -1.0 ) ||\n"
    "         ( screen_position[0].x >  1.0 && screen_position[1].x >  1.0 && screen_position[2].x >  1.0 && screen_position[3].x >  1.0 ) ||\n"
    "         ( screen_position[0].y < -1.0 && screen_position[1].y < -1.0 && screen_position[2].y < -1.0 && screen_position[3].y < -1.0 ) ||\n"
    "         ( screen_position[0].y >  1.0 && screen_position[1].y >  1.0 && screen_position[2].y >  1.0 && screen_position[3].y >  1.0 ) ) return;\n"
    "\n"
    "    id = id_in[0] * 3.0 + id_in[1] * 5.0 + id_in[2] * 7.0 + id_in[3] * 11.0;\n"
    "\n"
    "    int d321 = direction( 3, 2, 1 );\n"
    "    int d230 = direction( 2, 3, 0 );\n"
    "    int d103 = direction( 1, 0, 3 );\n"
    "    int d012 = direction( 0, 1, 2 );\n"
    "\n"
    "    int pos = d321 * 27 + d230 * 9 + d103 * 3 + d012;\n"
    "    vec2 t_pos = vec2( ( float(pos) + 0.5 ) / 81.0, 0.5 );\n"
    "    vec4 info = texture2D( decomposion_texture, t_pos );\n"
    "    int type = int( ( info.a * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p0   = int( ( info.x * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p1   = int( ( info.y * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p2   = int( ( info.z * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p3   = 6 - ( p0 + p1 + p2 );\n"
    "\n"
    "    if ( type == 1 )\n"
    "    {\n"
    "        create_type_1( p0, p1, p2, p3 );\n"
    "    }\n"
    "    else if ( type == 2 )\n"
    "    {\n"
    "        create_type_2( p0, p1, p2, p3 );\n"
    "    }\n"
    "    else if ( type == 3 )\n"
    "    {\n"
    "        create_type_3( p0, p1, p2, p3 );\n"
    "    }\n"
    "    else if ( type == 4 )\n"
    "    {\n"
    "        create_type_4( p0, p1, p2, p3 );\n"
    "    }\n"
    "\n"
    "}\n"
;

const std::string multiple_tetrahedra2 =
    "#version 120\n"
    "#extension GL_EXT_geometry_shader4 : enable\n"
    "#extension GL_EXT_gpu_shader4 : enable\n"
    "\n"
    "varying in vec4 position_in[4];\n"
    "varying in float value_in[4];\n"
    "varying in vec2 id_in[4];\n"
    "varying in vec3 normal_in[4];\n"
    "\n"
    "varying out vec3 position;\n"
    "varying out vec3 normal;\n"
    "varying out vec2 id;\n"
    "\n"
    "varying out float depth_front;\n"
    "varying out float depth_back;\n"
    "\n"
    "varying out float scalar_front;\n"
    "varying out float scalar_back;\n"
    "varying out float distance;\n"
    "\n"
    "uniform vec2 preintegration_scale_offset;\n"
    "uniform sampler2D decomposion_texture;\n"
    "\n"
    "vec3 screen_position[4];\n"
    "\n"
    "int direction( in int p0, in int p1, in int p2 )\n"
    "{\n"
    "    vec2 v1 = screen_position[p1].xy - screen_position[p0].xy;\n"
    "    vec2 v2 = screen_position[p2].xy - screen_position[p0].xy;\n"
    "    float cross_product = v1.x * v2.y - v1.y * v2.x;\n"
    "    return( int( sign( cross_product ) + 1.0 ) );\n"
    "}\n"
    "\n"
    "void emitExistPoint( const in int index, const in float dist )\n"
    "{\n"
    "    gl_Position = gl_PositionIn[index]; \n"
    "    position    = position_in[index].xyz;\n"
    "    depth_front = gl_PositionIn[index].z / gl_PositionIn[index].w;\n"
    "    depth_back  = depth_front;\n"
    "\n"
    "    normal = normal_in[index].xyz;\n"
    "\n"
    "    scalar_front = value_in[index];\n"
    "    scalar_back  = value_in[index];\n"
    "    distance     = dist;\n"
    "    EmitVertex();\n"
    "}\n"
    "\n"
    "void emitNewPoint(\n"
    "    const in vec4 center_position,\n"
    "    const in vec3 center_position_3D,\n"
    "    const in float center_another_depth,\n"
    "    const in vec3 center_normal_3D,\n"
    "    const in float center_scalar_front,\n"
    "    const in float center_scalar_back,\n"
    "    const in float center_distance )\n"
    "{\n"
    "    gl_Position = center_position;\n"
    "    position    = center_position_3D;\n"
    "    depth_front = center_position.z / center_position.w;\n"
    "    depth_back  = center_another_depth;\n"
    "\n"
    "    normal = center_normal_3D;\n"
    "\n"
    "    scalar_front = center_scalar_front;\n"
    "    scalar_back  = center_scalar_back;\n"
    "    distance     = center_distance;\n"
    "    EmitVertex();\n"
    "}\n"
    "\n"
    "\n"
    "float distance_to_texture_coord( const in float distance )\n"
    "{\n"
    "    return( distance * preintegration_scale_offset.x + preintegration_scale_offset.y );\n"
    "}\n"
    "\n"
    "void calculate_across_triangle_to_line_2D( out float r2, out float r3, in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    vec2 v01 = screen_position[p0].xy - screen_position[p1].xy;\n"
    "    vec2 v21 = screen_position[p2].xy - screen_position[p1].xy;\n"
    "    vec2 v31 = screen_position[p3].xy - screen_position[p1].xy;\n"
    "    float delta = v21.x * v31.y - v31.x * v21.y;\n"
    "    if ( delta == 0 )\n"
    "    {\n"
    "        r2 = r3 = 1.0 / 3.0;\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    float delta_inv = 1.0 / delta;\n"
    "    r2 = delta_inv * (  v31.y * v01.x - v31.x * v01.y );\n"
    "    r3 = delta_inv * ( -v21.y * v01.x + v21.x * v01.y );\n"
    "}\n"
    "\n"
    "float perspective_correct( const in float r, const in float p0z, const in float p1z )\n"
    "{\n"
    "    if ( p0z == p1z ) return r;\n"
    "\n"
    "    float p0z_inv = 1.0 / p0z;\n"
    "    float p1z_inv = 1.0 / p1z;\n"
    "    float pz_inv  = p0z_inv + ( p1z_inv - p0z_inv ) * r;\n"
    "    float pz = 1.0 / pz_inv;\n"
    "\n"
    "    float result = ( pz - p0z ) / ( p1z - p0z );\n"
    "    if ( result < 0.0 ) result = 0.0;\n"
    "    if ( result > 1.0 ) result = 1.0;\n"
    "    return( result );\n"
    "}\n"
    "\n"
    "void perspective_correct_triangle( inout float r2, inout float r3, in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    if ( r2 + r3 <= 0 ) return;\n"
    "    float p1z    = gl_PositionIn[p1].w;\n"
    "    float p2z    = gl_PositionIn[p2].w;\n"
    "    float p3z    = gl_PositionIn[p3].w;\n"
    "    float k_2D   = r2 + r3;\n"
    "    float r23_2D = r3 / k_2D;\n"
    "\n"
    "    float r23_3D = perspective_correct( r23_2D, p2z, p3z );\n"
    "\n"
    "    float p23z = p2z + ( p3z - p2z ) * r23_3D;\n"
    "    float k_3D = perspective_correct( k_2D, p1z, p23z );\n"
    "\n"
    "    r3 = r23_3D * k_3D;\n"
    "    r2 = k_3D - r3;\n"
    "}\n"
    "\n"
    "void perspective_correct_line( inout float r, const in int p0, const in int p1 )\n"
    "{\n"
    "    float p0z  = gl_PositionIn[p0].w;\n"
    "    float p1z  = gl_PositionIn[p1].w;\n"
    "    float r_3D = perspective_correct( r, p0z, p1z );\n"
    "\n"
    "    r = r_3D;\n"
    "}\n"
    "\n"
    "void calculate_across_line_to_line_2D( out float r1, out float r3, in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    vec2 v02 = screen_position[p0].xy - screen_position[p2].xy;\n"
    "    vec2 v01 = screen_position[p0].xy - screen_position[p1].xy;\n"
    "    vec2 v32 = screen_position[p3].xy - screen_position[p2].xy;\n"
    "    float delta = v01.x * v32.y - v32.x * v01.y;\n"
    "    if ( delta == 0 )\n"
    "    {\n"
    "        r1 = r3 = 1.0 / 2.0;\n"
    "        return;\n"
    "    }\n"
    "    float delta_inv = 1.0 / delta;\n"
    "    r1 = delta_inv * (  v32.y * v02.x - v32.x * v02.y );\n"
    "    r3 = delta_inv * ( -v01.y * v02.x + v01.x * v02.y );\n"
    "}\n"
    "\n"
    "void create_type_1( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "   float r2, r3;\n"
    "   calculate_across_triangle_to_line_2D( r2, r3, p0, p1, p2, p3 );\n"
    "   perspective_correct_triangle( r2, r3, p0, p1, p2, p3 );\n"
    "\n"
    "   vec4  p123 = position_in[p1] + ( position_in[p2]  - position_in[p1] ) * r2 + ( position_in[p3] - position_in[p1] ) * r3;\n"
    "   float s123 = value_in[p1] + ( value_in[p2] - value_in[p1] ) * r2 + ( value_in[p3] - value_in[p1] ) * r3;\n"
    "\n"
    "   vec4 center_position;\n"
    "   vec3 center_position_3D;\n"
    "   float center_scalar_front, center_scalar_back; \n"
    "\n"
    "   vec3 n123 = normal_in[p1] + ( normal_in[p2] - normal_in[p1] ) * r2 + ( normal_in[p3] - normal_in[p1] ) * p3;\n"
    "   vec3 center_normal_3D;\n"
    "\n"
    "    float a_depth;\n"
    "\n"
    "   if ( length( p123.z ) < length( position_in[p0].z ) )\n"
    "   {\n"
    "       center_position = gl_ProjectionMatrix * p123;\n"
    "       center_position_3D = p123.xyz;\n"
    "       vec4 tmp = gl_PositionIn[p0];\n"
    "       a_depth = tmp.z / tmp.w;\n"
    "\n"
    "       center_normal_3D = n123.xyz;\n"
    "\n"
    "       center_scalar_front = s123;\n"
    "       center_scalar_back = value_in[p0];\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       center_position = gl_PositionIn[p0];\n"
    "       center_position_3D = position_in[p0].xyz;\n"
    "       vec4 tmp = gl_ProjectionMatrix * p123;\n"
    "       a_depth = tmp.z / tmp.w;\n"
    "\n"
    "       center_normal_3D = normal_in[p0].xyz;\n"
    "\n"
    "       center_scalar_front = value_in[p0];\n"
    "       center_scalar_back = s123;\n"
    "   }\n"
    "\n"
    "   float center_distance = distance_to_texture_coord( length( position_in[p0] - p123 ) );\n"
    "\n"
    "    // p1-p2-C p2-C-p3 C-p3-p1\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    emitExistPoint( p2, 0.0 );\n"
    "    emitNewPoint( center_position, center_position_3D, a_depth, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "    emitExistPoint( p3, 0.0 );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    EndPrimitive();\n"
    "}\n"
    "\n"
    "void create_type_2( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "\n"
    "   float r1, r3;\n"
    "   calculate_across_line_to_line_2D( r1, r3, p0, p1, p2, p3 );\n"
    "   perspective_correct_line( r1, p0, p1 );\n"
    "   perspective_correct_line( r3, p2, p3 );\n"
    "\n"
    "   vec4  p01 = position_in[p0] + ( position_in[p1] - position_in[p0] ) * r1;\n"
    "   float s01 = value_in[p0] + ( value_in[p1] - value_in[p0] ) * r1;\n"
    "\n"
    "   vec4  p23 = position_in[p2] + ( position_in[p3]  - position_in[p2] ) * r3;\n"
    "   float s23 = value_in[p2] + ( value_in[p3] - value_in[p2] ) * r3;\n"
    "\n"
    "   vec4 center_position;\n"
    "   vec3 center_position_3D;\n"
    "   float center_scalar_front, center_scalar_back; \n"
    "\n"
    "   vec3 n01 = normal_in[p0] + ( normal_in[p1] - normal_in[p0] ) * r1;\n"
    "   vec3 n23 = normal_in[p2] + ( normal_in[p3] - normal_in[p2] ) * r3;\n"
    "   vec3 center_normal_3D;\n"
    "\n"
    "    float a_depth;\n"
    "\n"
    "   if ( length( p01.xyz ) < length( p23.xyz ) )\n"
    "   {\n"
    "       center_position = gl_ProjectionMatrix * p01;\n"
    "       center_position_3D = p01.xyz;\n"
    "       vec4 tmp = gl_ProjectionMatrix * p23;\n"
    "       a_depth = tmp.z / tmp.w;\n"
    "\n"
    "       center_normal_3D = n01.xyz;\n"
    "\n"
    "       center_scalar_front = s01;\n"
    "       center_scalar_back = s23;\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       center_position = gl_ProjectionMatrix * p23;\n"
    "       center_position_3D = p23.xyz;\n"
    "       vec4 tmp = gl_ProjectionMatrix * p01;\n"
    "       a_depth = tmp.z / tmp.w;\n"
    "\n"
    "       center_normal_3D = n23.xyz;\n"
    "\n"
    "       center_scalar_front = s23;\n"
    "       center_scalar_back = s01;\n"
    "   }\n"
    "\n"
    "   float center_distance = distance_to_texture_coord( length( p01.z - p23.z ) );\n"
    "\n"
    "    // right half: p0-p2-C, p2-C-p1\n"
    "    emitExistPoint( p0, 0.0 );\n"
    "    emitExistPoint( p2, 0.0 );\n"
    "    emitNewPoint( center_position, center_position_3D, a_depth, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    EndPrimitive();\n"
    "\n"
    "    // left half: p0-p3-C, p3-C-p1\n"
    "    emitExistPoint( p0, 0.0 );\n"
    "    emitExistPoint( p3, 0.0 );\n"
    "    emitNewPoint( center_position, center_position_3D, a_depth, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    EndPrimitive();\n"
    "}\n"
    "\n"
    "void create_type_3( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    create_type_2( p0, p1, p2, p3 );\n"
    "}\n"
    "\n"
    "void create_type_4( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "\n"
    "    int pFront, pBack;\n"
    "    if ( position_in[p2].z < position_in[p3].z )\n"
    "    {\n"
    "        pFront = p2;\n"
    "        pBack = p3;\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        pFront = p3;\n"
    "        pBack = p2;\n"
    "    }\n"
    "\n"
    "    float a_depth = gl_PositionIn[pFront].z / gl_PositionIn[pFront].w;\n"
    "\n"
    "    float center_distance = distance_to_texture_coord( length( position_in[pBack] - position_in[pFront] ) );\n"
    "    emitExistPoint( p0, 0.0 );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    emitNewPoint( gl_PositionIn[pBack], position_in[pBack].xyz, a_depth, normal_in[pBack].xyz, value_in[pBack], value_in[pFront], center_distance );\n"
    "    //emitExistPoint( pFront, center_distance );\n"
    "    EndPrimitive();\n"
    "}\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    if ( gl_PositionIn[0].w <= 0 ||\n"
    "         gl_PositionIn[1].w <= 0 ||\n"
    "         gl_PositionIn[2].w <= 0 ||\n"
    "         gl_PositionIn[3].w <= 0 ) return;\n"
    "\n"
    "    screen_position[0] = gl_PositionIn[0].xyz / gl_PositionIn[0].w;\n"
    "    screen_position[1] = gl_PositionIn[1].xyz / gl_PositionIn[1].w;\n"
    "    screen_position[2] = gl_PositionIn[2].xyz / gl_PositionIn[2].w;\n"
    "    screen_position[3] = gl_PositionIn[3].xyz / gl_PositionIn[3].w;\n"
    "\n"
    "    if ( ( screen_position[0].x < -1.0 && screen_position[1].x < -1.0 && screen_position[2].x < -1.0 && screen_position[3].x < -1.0 ) ||\n"
    "         ( screen_position[0].x >  1.0 && screen_position[1].x >  1.0 && screen_position[2].x >  1.0 && screen_position[3].x >  1.0 ) ||\n"
    "         ( screen_position[0].y < -1.0 && screen_position[1].y < -1.0 && screen_position[2].y < -1.0 && screen_position[3].y < -1.0 ) ||\n"
    "         ( screen_position[0].y >  1.0 && screen_position[1].y >  1.0 && screen_position[2].y >  1.0 && screen_position[3].y >  1.0 ) ) return;\n"
    "\n"
    "    id = id_in[0] * 3.0 + id_in[1] * 5.0 + id_in[2] * 7.0 + id_in[3] * 11.0;\n"
    "\n"
    "    int d321 = direction( 3, 2, 1 );\n"
    "    int d230 = direction( 2, 3, 0 );\n"
    "    int d103 = direction( 1, 0, 3 );\n"
    "    int d012 = direction( 0, 1, 2 );\n"
    "\n"
    "    int pos = d321 * 27 + d230 * 9 + d103 * 3 + d012;\n"
    "    vec2 t_pos = vec2( ( float(pos) + 0.5 ) / 81.0, 0.5 );\n"
    "    vec4 info = texture2D( decomposion_texture, t_pos );\n"
    "    int type = int( ( info.a * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p0   = int( ( info.x * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p1   = int( ( info.y * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p2   = int( ( info.z * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p3   = 6 - ( p0 + p1 + p2 );\n"
    "\n"
    "    if ( type == 1 )\n"
    "    {\n"
    "        create_type_1( p0, p1, p2, p3 );\n"
    "    }\n"
    "    else if ( type == 2 )\n"
    "    {\n"
    "        create_type_2( p0, p1, p2, p3 );\n"
    "    }\n"
    "    else if ( type == 3 )\n"
    "    {\n"
    "        create_type_3( p0, p1, p2, p3 );\n"
    "    }\n"
    "    else if ( type == 4 )\n"
    "    {\n"
    "        create_type_4( p0, p1, p2, p3 );\n"
    "    }\n"
    "\n"
    "}\n"
;

const std::string multivariate_tetrahedra =
    "#version 120\n"
    "#extension GL_EXT_geometry_shader4 : enable\n"
    "#extension GL_EXT_gpu_shader4 : enable\n"
    "\n"
    "varying in vec4 position_in[4];\n"
    "varying in vec2 value_in[4];\n"
    "varying in vec2 id_in[4];\n"
    "varying in vec3 normal_in[4];\n"
    "\n"
    "varying out vec3 position;\n"
    "varying out vec3 normal;\n"
    "varying out vec2 id;\n"
    "\n"
    "varying out vec2 scalar_front;\n"
    "varying out vec2 scalar_back;\n"
    "varying out float distance;\n"
    "\n"
    "uniform vec2 preintegration_scale_offset;\n"
    "uniform sampler2D decomposion_texture;\n"
    "\n"
    "vec3 screen_position[4];\n"
    "\n"
    "int direction( in int p0, in int p1, in int p2 )\n"
    "{\n"
    "    vec2 v1 = screen_position[p1].xy - screen_position[p0].xy;\n"
    "    vec2 v2 = screen_position[p2].xy - screen_position[p0].xy;\n"
    "    float cross_product = v1.x * v2.y - v1.y * v2.x;\n"
    "    return( int( sign( cross_product ) + 1.0 ) );\n"
    "}\n"
    "\n"
    "void emitExistPoint( const in int index, const in float dist )\n"
    "{\n"
    "    gl_Position = gl_PositionIn[index]; \n"
    "    position    = position_in[index].xyz;\n"
    "\n"
    "    normal = normal_in[index].xyz;\n"
    "\n"
    "    scalar_front = value_in[index];\n"
    "    scalar_back  = value_in[index];\n"
    "    distance     = dist;\n"
    "    EmitVertex();\n"
    "}\n"
    "\n"
    "void emitNewPoint(\n"
    "    const in vec4 center_position,\n"
    "    const in vec3 center_position_3D,\n"
    "    const in vec3 center_normal_3D,\n"
    "    const in vec2 center_scalar_front,\n"
    "    const in vec2 center_scalar_back,\n"
    "    const in float center_distance )\n"
    "{\n"
    "    gl_Position = center_position;\n"
    "    position    = center_position_3D;\n"
    "\n"
    "    normal = center_normal_3D;\n"
    "\n"
    "    scalar_front = center_scalar_front;\n"
    "    scalar_back  = center_scalar_back;\n"
    "    distance     = center_distance;\n"
    "    EmitVertex();\n"
    "}\n"
    "\n"
    "float distance_to_texture_coord( const in float distance )\n"
    "{\n"
    "    return( distance * preintegration_scale_offset.x + preintegration_scale_offset.y );\n"
    "}\n"
    "\n"
    "void calculate_across_triangle_to_line_2D( out float r2, out float r3, in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    vec2 v01 = screen_position[p0].xy - screen_position[p1].xy;\n"
    "    vec2 v21 = screen_position[p2].xy - screen_position[p1].xy;\n"
    "    vec2 v31 = screen_position[p3].xy - screen_position[p1].xy;\n"
    "    float delta = v21.x * v31.y - v31.x * v21.y;\n"
    "    if ( delta == 0 )\n"
    "    {\n"
    "        r2 = r3 = 1.0 / 3.0;\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    float delta_inv = 1.0 / delta;\n"
    "    r2 = delta_inv * (  v31.y * v01.x - v31.x * v01.y );\n"
    "    r3 = delta_inv * ( -v21.y * v01.x + v21.x * v01.y );\n"
    "}\n"
    "\n"
    "float perspective_correct( const in float r, const in float p0z, const in float p1z )\n"
    "{\n"
    "    if ( p0z == p1z ) return r;\n"
    "\n"
    "    float p0z_inv = 1.0 / p0z;\n"
    "    float p1z_inv = 1.0 / p1z;\n"
    "    float pz_inv  = p0z_inv + ( p1z_inv - p0z_inv ) * r;\n"
    "    float pz = 1.0 / pz_inv;\n"
    "\n"
    "    float result = ( pz - p0z ) / ( p1z - p0z );\n"
    "    if ( result < 0.0 ) result = 0.0;\n"
    "    if ( result > 1.0 ) result = 1.0;\n"
    "    return( result );\n"
    "}\n"
    "\n"
    "void perspective_correct_triangle( inout float r2, inout float r3, in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    if ( r2 + r3 <= 0 ) return;\n"
    "    float p1z    = gl_PositionIn[p1].w;\n"
    "    float p2z    = gl_PositionIn[p2].w;\n"
    "    float p3z    = gl_PositionIn[p3].w;\n"
    "    float k_2D   = r2 + r3;\n"
    "    float r23_2D = r3 / k_2D;\n"
    "\n"
    "    float r23_3D = perspective_correct( r23_2D, p2z, p3z );\n"
    "\n"
    "    float p23z = p2z + ( p3z - p2z ) * r23_3D;\n"
    "    float k_3D = perspective_correct( k_2D, p1z, p23z );\n"
    "\n"
    "    r3 = r23_3D * k_3D;\n"
    "    r2 = k_3D - r3;\n"
    "}\n"
    "\n"
    "void perspective_correct_line( inout float r, const in int p0, const in int p1 )\n"
    "{\n"
    "    float p0z  = gl_PositionIn[p0].w;\n"
    "    float p1z  = gl_PositionIn[p1].w;\n"
    "    float r_3D = perspective_correct( r, p0z, p1z );\n"
    "\n"
    "    r = r_3D;\n"
    "}\n"
    "\n"
    "void calculate_across_line_to_line_2D( out float r1, out float r3, in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    vec2 v02 = screen_position[p0].xy - screen_position[p2].xy;\n"
    "    vec2 v01 = screen_position[p0].xy - screen_position[p1].xy;\n"
    "    vec2 v32 = screen_position[p3].xy - screen_position[p2].xy;\n"
    "    float delta = v01.x * v32.y - v32.x * v01.y;\n"
    "    if ( delta == 0 )\n"
    "    {\n"
    "        r1 = r3 = 1.0 / 2.0;\n"
    "        return;\n"
    "    }\n"
    "    float delta_inv = 1.0 / delta;\n"
    "    r1 = delta_inv * (  v32.y * v02.x - v32.x * v02.y );\n"
    "    r3 = delta_inv * ( -v01.y * v02.x + v01.x * v02.y );\n"
    "}\n"
    "\n"
    "void create_type_1( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "   float r2, r3;\n"
    "   calculate_across_triangle_to_line_2D( r2, r3, p0, p1, p2, p3 );\n"
    "   perspective_correct_triangle( r2, r3, p0, p1, p2, p3 );\n"
    "\n"
    "   vec4  p123 = position_in[p1] + ( position_in[p2]  - position_in[p1] ) * r2 + ( position_in[p3] - position_in[p1] ) * r3;\n"
    "   vec2 s123 = value_in[p1] + ( value_in[p2] - value_in[p1] ) * r2 + ( value_in[p3] - value_in[p1] ) * r3;\n"
    "\n"
    "   vec4 center_position;\n"
    "   vec3 center_position_3D;\n"
    "   vec2 center_scalar_front, center_scalar_back; \n"
    "\n"
    "   vec3 n123 = normal_in[p1] + ( normal_in[p2] - normal_in[p1] ) * r2 + ( normal_in[p3] - normal_in[p1] ) * p3;\n"
    "   vec3 center_normal_3D;\n"
    "\n"
    "   if ( length( p123.z ) < length( position_in[p0].z ) )\n"
    "   {\n"
    "       center_position = gl_ProjectionMatrix * p123;\n"
    "       center_position_3D = p123.xyz;\n"
    "\n"
    "       center_normal_3D = n123.xyz;\n"
    "\n"
    "       center_scalar_front = s123;\n"
    "       center_scalar_back = value_in[p0];\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       center_position = gl_PositionIn[p0];\n"
    "       center_position_3D = position_in[p0].xyz;\n"
    "\n"
    "       center_normal_3D = normal_in[p0].xyz;\n"
    "\n"
    "       center_scalar_front = value_in[p0];\n"
    "       center_scalar_back = s123;\n"
    "   }\n"
    "\n"
    "   float center_distance = distance_to_texture_coord( length( position_in[p0] - p123 ) );\n"
    "\n"
    "    // p1-p2-C p2-C-p3 C-p3-p1\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    emitExistPoint( p2, 0.0 );\n"
    "    emitNewPoint( center_position, center_position_3D, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "    emitExistPoint( p3, 0.0 );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    EndPrimitive();\n"
    "}\n"
    "\n"
    "void create_type_2( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "\n"
    "   float r1, r3;\n"
    "   calculate_across_line_to_line_2D( r1, r3, p0, p1, p2, p3 );\n"
    "   perspective_correct_line( r1, p0, p1 );\n"
    "   perspective_correct_line( r3, p2, p3 );\n"
    "\n"
    "   vec4  p01 = position_in[p0] + ( position_in[p1] - position_in[p0] ) * r1;\n"
    "   vec2 s01 = value_in[p0] + ( value_in[p1] - value_in[p0] ) * r1;\n"
    "\n"
    "   vec4  p23 = position_in[p2] + ( position_in[p3]  - position_in[p2] ) * r3;\n"
    "   vec2 s23 = value_in[p2] + ( value_in[p3] - value_in[p2] ) * r3;\n"
    "\n"
    "   vec4 center_position;\n"
    "   vec3 center_position_3D;\n"
    "   vec2 center_scalar_front, center_scalar_back; \n"
    "\n"
    "   vec3 n01 = normal_in[p0] + ( normal_in[p1] - normal_in[p0] ) * r1;\n"
    "   vec3 n23 = normal_in[p2] + ( normal_in[p3] - normal_in[p2] ) * r3;\n"
    "   vec3 center_normal_3D;\n"
    "\n"
    "   if ( length( p01.xyz ) < length( p23.xyz ) )\n"
    "   {\n"
    "       center_position = gl_ProjectionMatrix * p01;\n"
    "       center_position_3D = p01.xyz;\n"
    "\n"
    "       center_normal_3D = n01.xyz;\n"
    "\n"
    "       center_scalar_front = s01;\n"
    "       center_scalar_back = s23;\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "       center_position = gl_ProjectionMatrix * p23;\n"
    "       center_position_3D = p23.xyz;\n"
    "\n"
    "       center_normal_3D = n23.xyz;\n"
    "\n"
    "       center_scalar_front = s23;\n"
    "       center_scalar_back = s01;\n"
    "   }\n"
    "\n"
    "   float center_distance = distance_to_texture_coord( length( p01.z - p23.z ) );\n"
    "\n"
    "    // right half: p0-p2-C, p2-C-p1\n"
    "    emitExistPoint( p0, 0.0 );\n"
    "    emitExistPoint( p2, 0.0 );\n"
    "    emitNewPoint( center_position, center_position_3D, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    EndPrimitive();\n"
    "\n"
    "    // left half: p0-p3-C, p3-C-p1\n"
    "    emitExistPoint( p0, 0.0 );\n"
    "    emitExistPoint( p3, 0.0 );\n"
    "    emitNewPoint( center_position, center_position_3D, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    EndPrimitive();\n"
    "}\n"
    "\n"
    "void create_type_3( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    create_type_2( p0, p1, p2, p3 );\n"
    "}\n"
    "\n"
    "void create_type_4( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "\n"
    "    int pFront, pBack;\n"
    "    if ( position_in[p2].z < position_in[p3].z )\n"
    "    {\n"
    "        pFront = p2;\n"
    "        pBack = p3;\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        pFront = p3;\n"
    "        pBack = p2;\n"
    "    }\n"
    "    float center_distance = distance_to_texture_coord( length( position_in[pBack] - position_in[pFront] ) );\n"
    "    emitExistPoint( p0, 0.0 );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    emitExistPoint( pFront, center_distance );\n"
    "    EndPrimitive();\n"
    "}\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    if ( gl_PositionIn[0].w <= 0 ||\n"
    "         gl_PositionIn[1].w <= 0 ||\n"
    "         gl_PositionIn[2].w <= 0 ||\n"
    "         gl_PositionIn[3].w <= 0 ) return;\n"
    "\n"
    "    screen_position[0] = gl_PositionIn[0].xyz / gl_PositionIn[0].w;\n"
    "    screen_position[1] = gl_PositionIn[1].xyz / gl_PositionIn[1].w;\n"
    "    screen_position[2] = gl_PositionIn[2].xyz / gl_PositionIn[2].w;\n"
    "    screen_position[3] = gl_PositionIn[3].xyz / gl_PositionIn[3].w;\n"
    "\n"
    "    if ( ( screen_position[0].x < -1.0 && screen_position[1].x < -1.0 && screen_position[2].x < -1.0 && screen_position[3].x < -1.0 ) ||\n"
    "         ( screen_position[0].x >  1.0 && screen_position[1].x >  1.0 && screen_position[2].x >  1.0 && screen_position[3].x >  1.0 ) ||\n"
    "         ( screen_position[0].y < -1.0 && screen_position[1].y < -1.0 && screen_position[2].y < -1.0 && screen_position[3].y < -1.0 ) ||\n"
    "         ( screen_position[0].y >  1.0 && screen_position[1].y >  1.0 && screen_position[2].y >  1.0 && screen_position[3].y >  1.0 ) ) return;\n"
    "\n"
    "    id = id_in[0] * 3.0 + id_in[1] * 5.0 + id_in[2] * 7.0 + id_in[3] * 11.0;\n"
    "\n"
    "    int d321 = direction( 3, 2, 1 );\n"
    "    int d230 = direction( 2, 3, 0 );\n"
    "    int d103 = direction( 1, 0, 3 );\n"
    "    int d012 = direction( 0, 1, 2 );\n"
    "\n"
    "    int pos = d321 * 27 + d230 * 9 + d103 * 3 + d012;\n"
    "    vec2 t_pos = vec2( ( float(pos) + 0.5 ) / 81.0, 0.5 );\n"
    "    vec4 info = texture2D( decomposion_texture, t_pos );\n"
    "    int type = int( ( info.a * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p0   = int( ( info.x * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p1   = int( ( info.y * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p2   = int( ( info.z * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p3   = 6 - ( p0 + p1 + p2 );\n"
    "\n"
    "    if ( type == 1 )\n"
    "    {\n"
    "        create_type_1( p0, p1, p2, p3 );\n"
    "    }\n"
    "    else if ( type == 2 )\n"
    "    {\n"
    "        create_type_2( p0, p1, p2, p3 );\n"
    "    }\n"
    "    else if ( type == 3 )\n"
    "    {\n"
    "        create_type_3( p0, p1, p2, p3 );\n"
    "    }\n"
    "    else if ( type == 4 )\n"
    "    {\n"
    "        create_type_4( p0, p1, p2, p3 );\n"
    "    }\n"
    "\n"
    "}\n"
;

const std::string tetrahedra =
    "#version 120\n"
    "#extension GL_EXT_geometry_shader4 : enable\n"
    "#extension GL_EXT_gpu_shader4 : enable\n"
    "\n"
    "varying in vec4 position_in[4];\n"
    "varying in float value_in[4];\n"
    "varying in vec2 id_in[4];\n"
    "varying in vec3 normal_in[4];\n"
    "\n"
    "varying out vec3 position;\n"
    "varying out vec3 normal;\n"
    "varying out vec2 id;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "varying out float depth_front;\n"
    "varying out float depth_back;\n"
    "#endif\n"
    "\n"
    "varying out float scalar_front;\n"
    "varying out float scalar_back;\n"
    "varying out float distance;\n"
    "\n"
    "uniform vec2 preintegration_scale_offset;\n"
    "uniform sampler2D decomposion_texture;\n"
    "\n"
    "vec3 screen_position[4];\n"
    "\n"
    "int direction( in int p0, in int p1, in int p2 )\n"
    "{\n"
    "    vec2 v1 = screen_position[p1].xy - screen_position[p0].xy;\n"
    "    vec2 v2 = screen_position[p2].xy - screen_position[p0].xy;\n"
    "    float cross_product = v1.x * v2.y - v1.y * v2.x;\n"
    "    return( int( sign( cross_product ) + 1.0 ) );\n"
    "}\n"
    "\n"
    "void emitExistPoint( const in int index, const in float dist )\n"
    "{\n"
    "    gl_Position = gl_PositionIn[index]; \n"
    "    position    = position_in[index].xyz;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    depth_front = gl_PositionIn[index].z / gl_PositionIn[index].w;\n"
    "    depth_back  = depth_front;\n"
    "#endif\n"
    "\n"
    "    normal = normal_in[index].xyz;\n"
    "\n"
    "    scalar_front = value_in[index];\n"
    "    scalar_back  = value_in[index];\n"
    "    distance     = dist;\n"
    "    EmitVertex();\n"
    "}\n"
    "\n"
    "void emitNewPoint(\n"
    "    const in vec4 center_position,\n"
    "    const in vec3 center_position_3D,\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    const in float center_another_depth,\n"
    "#endif\n"
    "    const in vec3 center_normal_3D,\n"
    "    const in float center_scalar_front,\n"
    "    const in float center_scalar_back,\n"
    "    const in float center_distance )\n"
    "{\n"
    "    gl_Position = center_position;\n"
    "    position    = center_position_3D;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    depth_front = center_position.z / center_position.w;\n"
    "    depth_back  = center_another_depth;\n"
    "#endif\n"
    "\n"
    "    normal = center_normal_3D;\n"
    "\n"
    "    scalar_front = center_scalar_front;\n"
    "    scalar_back  = center_scalar_back;\n"
    "    distance     = center_distance;\n"
    "    EmitVertex();\n"
    "}\n"
    "\n"
    "float distance_to_texture_coord( const in float distance )\n"
    "{\n"
    "    return( distance * preintegration_scale_offset.x + preintegration_scale_offset.y );\n"
    "}\n"
    "\n"
    "void calculate_across_triangle_to_line_2D( out float r2, out float r3, in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    vec2 v01 = screen_position[p0].xy - screen_position[p1].xy;\n"
    "    vec2 v21 = screen_position[p2].xy - screen_position[p1].xy;\n"
    "    vec2 v31 = screen_position[p3].xy - screen_position[p1].xy;\n"
    "    float delta = v21.x * v31.y - v31.x * v21.y;\n"
    "    if ( delta == 0 )\n"
    "    {\n"
    "        r2 = r3 = 1.0 / 3.0;\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    float delta_inv = 1.0 / delta;\n"
    "    r2 = delta_inv * (  v31.y * v01.x - v31.x * v01.y );\n"
    "    r3 = delta_inv * ( -v21.y * v01.x + v21.x * v01.y );\n"
    "}\n"
    "\n"
    "float perspective_correct( const in float r, const in float p0z, const in float p1z )\n"
    "{\n"
    "    if ( p0z == p1z ) return r;\n"
    "\n"
    "    float p0z_inv = 1.0 / p0z;\n"
    "    float p1z_inv = 1.0 / p1z;\n"
    "    float pz_inv  = p0z_inv + ( p1z_inv - p0z_inv ) * r;\n"
    "    float pz = 1.0 / pz_inv;\n"
    "\n"
    "    float result = ( pz - p0z ) / ( p1z - p0z );\n"
    "    if ( result < 0.0 ) result = 0.0;\n"
    "    if ( result > 1.0 ) result = 1.0;\n"
    "    return( result );\n"
    "}\n"
    "\n"
    "void perspective_correct_triangle( inout float r2, inout float r3, in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    if ( r2 + r3 <= 0 ) return;\n"
    "    float p1z    = gl_PositionIn[p1].w;\n"
    "    float p2z    = gl_PositionIn[p2].w;\n"
    "    float p3z    = gl_PositionIn[p3].w;\n"
    "    float k_2D   = r2 + r3;\n"
    "    float r23_2D = r3 / k_2D;\n"
    "\n"
    "    float r23_3D = perspective_correct( r23_2D, p2z, p3z );\n"
    "\n"
    "    float p23z = p2z + ( p3z - p2z ) * r23_3D;\n"
    "    float k_3D = perspective_correct( k_2D, p1z, p23z );\n"
    "\n"
    "    r3 = r23_3D * k_3D;\n"
    "    r2 = k_3D - r3;\n"
    "}\n"
    "\n"
    "void perspective_correct_line( inout float r, const in int p0, const in int p1 )\n"
    "{\n"
    "    float p0z  = gl_PositionIn[p0].w;\n"
    "    float p1z  = gl_PositionIn[p1].w;\n"
    "    float r_3D = perspective_correct( r, p0z, p1z );\n"
    "\n"
    "    r = r_3D;\n"
    "}\n"
    "\n"
    "void calculate_across_line_to_line_2D( out float r1, out float r3, in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    vec2 v02 = screen_position[p0].xy - screen_position[p2].xy;\n"
    "    vec2 v01 = screen_position[p0].xy - screen_position[p1].xy;\n"
    "    vec2 v32 = screen_position[p3].xy - screen_position[p2].xy;\n"
    "    float delta = v01.x * v32.y - v32.x * v01.y;\n"
    "    if ( delta == 0 )\n"
    "    {\n"
    "        r1 = r3 = 1.0 / 2.0;\n"
    "        return;\n"
    "    }\n"
    "    float delta_inv = 1.0 / delta;\n"
    "    r1 = delta_inv * (  v32.y * v02.x - v32.x * v02.y );\n"
    "    r3 = delta_inv * ( -v01.y * v02.x + v01.x * v02.y );\n"
    "}\n"
    "\n"
    "void create_type_1( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "   float r2, r3;\n"
    "   calculate_across_triangle_to_line_2D( r2, r3, p0, p1, p2, p3 );\n"
    "   perspective_correct_triangle( r2, r3, p0, p1, p2, p3 );\n"
    "\n"
    "   vec4  p123 = position_in[p1] + ( position_in[p2]  - position_in[p1] ) * r2 + ( position_in[p3] - position_in[p1] ) * r3;\n"
    "   float s123 = value_in[p1] + ( value_in[p2] - value_in[p1] ) * r2 + ( value_in[p3] - value_in[p1] ) * r3;\n"
    "\n"
    "   vec4 center_position;\n"
    "   vec3 center_position_3D;\n"
    "   float center_scalar_front, center_scalar_back; \n"
    "\n"
    "   vec3 n123 = normal_in[p1] + ( normal_in[p2] - normal_in[p1] ) * r2 + ( normal_in[p3] - normal_in[p1] ) * p3;\n"
    "   vec3 center_normal_3D;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    float a_depth;\n"
    "#endif\n"
    "\n"
    "   if ( length( p123.z ) < length( position_in[p0].z ) )\n"
    "   {\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "        vec4 tmp = gl_PositionIn[p0];\n"
    "        a_depth = tmp.z / tmp.w;\n"
    "#endif\n"
    "\n"
    "       center_position = gl_ProjectionMatrix * p123;\n"
    "       center_position_3D = p123.xyz;\n"
    "\n"
    "       center_normal_3D = n123.xyz;\n"
    "\n"
    "       center_scalar_front = s123;\n"
    "       center_scalar_back = value_in[p0];\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "        vec4 tmp = gl_ProjectionMatrix * p123;\n"
    "        a_depth = tmp.z / tmp.w;\n"
    "#endif\n"
    "\n"
    "       center_position = gl_PositionIn[p0];\n"
    "       center_position_3D = position_in[p0].xyz;\n"
    "\n"
    "       center_normal_3D = normal_in[p0].xyz;\n"
    "\n"
    "       center_scalar_front = value_in[p0];\n"
    "       center_scalar_back = s123;\n"
    "   }\n"
    "\n"
    "   float center_distance = distance_to_texture_coord( length( position_in[p0] - p123 ) );\n"
    "\n"
    "    // p1-p2-C p2-C-p3 C-p3-p1\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    emitExistPoint( p2, 0.0 );\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    emitNewPoint( center_position, center_position_3D, a_depth, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "#else\n"
    "    emitNewPoint( center_position, center_position_3D, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "#endif\n"
    "    emitExistPoint( p3, 0.0 );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    EndPrimitive();\n"
    "}\n"
    "\n"
    "void create_type_2( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "\n"
    "   float r1, r3;\n"
    "   calculate_across_line_to_line_2D( r1, r3, p0, p1, p2, p3 );\n"
    "   perspective_correct_line( r1, p0, p1 );\n"
    "   perspective_correct_line( r3, p2, p3 );\n"
    "\n"
    "   vec4  p01 = position_in[p0] + ( position_in[p1] - position_in[p0] ) * r1;\n"
    "   float s01 = value_in[p0] + ( value_in[p1] - value_in[p0] ) * r1;\n"
    "\n"
    "   vec4  p23 = position_in[p2] + ( position_in[p3]  - position_in[p2] ) * r3;\n"
    "   float s23 = value_in[p2] + ( value_in[p3] - value_in[p2] ) * r3;\n"
    "\n"
    "   vec4 center_position;\n"
    "   vec3 center_position_3D;\n"
    "   float center_scalar_front, center_scalar_back; \n"
    "\n"
    "   vec3 n01 = normal_in[p0] + ( normal_in[p1] - normal_in[p0] ) * r1;\n"
    "   vec3 n23 = normal_in[p2] + ( normal_in[p3] - normal_in[p2] ) * r3;\n"
    "   vec3 center_normal_3D;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    float a_depth;\n"
    "#endif\n"
    "\n"
    "   if ( length( p01.xyz ) < length( p23.xyz ) )\n"
    "   {\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "        vec4 tmp = gl_ProjectionMatrix * p23;\n"
    "        a_depth = tmp.z / tmp.w;\n"
    "#endif\n"
    "\n"
    "       center_position = gl_ProjectionMatrix * p01;\n"
    "       center_position_3D = p01.xyz;\n"
    "\n"
    "       center_normal_3D = n01.xyz;\n"
    "\n"
    "       center_scalar_front = s01;\n"
    "       center_scalar_back = s23;\n"
    "   }\n"
    "   else\n"
    "   {\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "        vec4 tmp = gl_ProjectionMatrix * p01;\n"
    "        a_depth = tmp.z / tmp.w;\n"
    "#endif\n"
    "\n"
    "       center_position = gl_ProjectionMatrix * p23;\n"
    "       center_position_3D = p23.xyz;\n"
    "\n"
    "       center_normal_3D = n23.xyz;\n"
    "\n"
    "       center_scalar_front = s23;\n"
    "       center_scalar_back = s01;\n"
    "   }\n"
    "\n"
    "   float center_distance = distance_to_texture_coord( length( p01.z - p23.z ) );\n"
    "\n"
    "    // right half: p0-p2-C, p2-C-p1\n"
    "    emitExistPoint( p0, 0.0 );\n"
    "    emitExistPoint( p2, 0.0 );\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    emitNewPoint( center_position, center_position_3D, a_depth, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "#else\n"
    "    emitNewPoint( center_position, center_position_3D, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "#endif\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    EndPrimitive();\n"
    "\n"
    "    // left half: p0-p3-C, p3-C-p1\n"
    "    emitExistPoint( p0, 0.0 );\n"
    "    emitExistPoint( p3, 0.0 );\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    emitNewPoint( center_position, center_position_3D, a_depth, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "#else\n"
    "    emitNewPoint( center_position, center_position_3D, center_normal_3D, center_scalar_front, center_scalar_back, center_distance );\n"
    "#endif\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "    EndPrimitive();\n"
    "}\n"
    "\n"
    "void create_type_3( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    create_type_2( p0, p1, p2, p3 );\n"
    "}\n"
    "\n"
    "void create_type_4( in int p0, in int p1, in int p2, in int p3 )\n"
    "{\n"
    "    int pFront, pBack;\n"
    "    if ( position_in[p2].z < position_in[p3].z )\n"
    "    {\n"
    "        pFront = p2;\n"
    "        pBack = p3;\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        pFront = p3;\n"
    "        pBack = p2;\n"
    "    }\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    float a_depth = gl_PositionIn[pBack].z / gl_PositionIn[pBack].w;\n"
    "#endif\n"
    "\n"
    "    float center_distance = distance_to_texture_coord( length( position_in[pBack] - position_in[pFront] ) );\n"
    "    emitExistPoint( p0, 0.0 );\n"
    "    emitExistPoint( p1, 0.0 );\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    emitNewPoint( gl_PositionIn[pFront], position_in[pFront].xyz, a_depth, normal_in[pFront].xyz, value_in[pBack], value_in[pFront], center_distance );\n"
    "#else\n"
    "    emitExistPoint( pFront, center_distance );\n"
    "#endif\n"
    "    EndPrimitive();\n"
    "}\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    if ( gl_PositionIn[0].w <= 0 ||\n"
    "         gl_PositionIn[1].w <= 0 ||\n"
    "         gl_PositionIn[2].w <= 0 ||\n"
    "         gl_PositionIn[3].w <= 0 ) return;\n"
    "\n"
    "    screen_position[0] = gl_PositionIn[0].xyz / gl_PositionIn[0].w;\n"
    "    screen_position[1] = gl_PositionIn[1].xyz / gl_PositionIn[1].w;\n"
    "    screen_position[2] = gl_PositionIn[2].xyz / gl_PositionIn[2].w;\n"
    "    screen_position[3] = gl_PositionIn[3].xyz / gl_PositionIn[3].w;\n"
    "\n"
    "    if ( ( screen_position[0].x < -1.0 && screen_position[1].x < -1.0 && screen_position[2].x < -1.0 && screen_position[3].x < -1.0 ) ||\n"
    "         ( screen_position[0].x >  1.0 && screen_position[1].x >  1.0 && screen_position[2].x >  1.0 && screen_position[3].x >  1.0 ) ||\n"
    "         ( screen_position[0].y < -1.0 && screen_position[1].y < -1.0 && screen_position[2].y < -1.0 && screen_position[3].y < -1.0 ) ||\n"
    "         ( screen_position[0].y >  1.0 && screen_position[1].y >  1.0 && screen_position[2].y >  1.0 && screen_position[3].y >  1.0 ) ) return;\n"
    "\n"
    "    id = id_in[0] * 3.0 + id_in[1] * 5.0 + id_in[2] * 7.0 + id_in[3] * 11.0;\n"
    "\n"
    "    int d321 = direction( 3, 2, 1 );\n"
    "    int d230 = direction( 2, 3, 0 );\n"
    "    int d103 = direction( 1, 0, 3 );\n"
    "    int d012 = direction( 0, 1, 2 );\n"
    "\n"
    "    int pos = d321 * 27 + d230 * 9 + d103 * 3 + d012;\n"
    "    vec2 t_pos = vec2( ( float(pos) + 0.5 ) / 81.0, 0.5 );\n"
    "    vec4 info = texture2D( decomposion_texture, t_pos );\n"
    "    int type = int( ( info.a * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p0   = int( ( info.x * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p1   = int( ( info.y * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p2   = int( ( info.z * 255.0 + 16.0 ) / 32.0 );\n"
    "    int p3   = 6 - ( p0 + p1 + p2 );\n"
    "\n"
    "    if ( type == 1 )\n"
    "    {\n"
    "        create_type_1( p0, p1, p2, p3 );\n"
    "    }\n"
    "    else if ( type == 2 )\n"
    "    {\n"
    "        create_type_2( p0, p1, p2, p3 );\n"
    "    }\n"
    "    else if ( type == 3 )\n"
    "    {\n"
    "        create_type_3( p0, p1, p2, p3 );\n"
    "    }\n"
    "    else if ( type == 4 )\n"
    "    {\n"
    "        create_type_4( p0, p1, p2, p3 );\n"
    "    }\n"
    "\n"
    "}\n"
;

} // end of namespace Geometry

namespace Fragment
{

const std::string line =
    "varying vec3 position;\n"
    "varying vec2 id;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "varying float depth;\n"
    "#endif\n"
    "\n"
    "uniform sampler2D random_texture;\n"
    "\n"
    "uniform vec2 screen_scale;\n"
    "uniform vec2 screen_scale_inv;\n"
    "\n"
    "uniform float random_texture_size_inv;\n"
    "uniform vec2 random_offset;\n"
    "\n"
    "uniform float opacity;\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    if ( opacity == 0.0 ) { discard; return; }\n"
    "\n"
    "    if ( opacity < 0.99999 )\n"
    "    {\n"
    "        vec2 random_position = ( vec2( float( int( id.x ) * 73 ), float( int( id.y ) * 31 ) ) \n"
    "                    + random_offset + gl_FragCoord.xy ) * random_texture_size_inv;\n"
    "\n"
    "        float randf = texture2D( random_texture, random_position ).a;\n"
    "        if ( randf > opacity ) { discard; return; }\n"
    "    }\n"
    "\n"
    "    gl_FragColor = vec4( gl_Color.rgb, 1.0 );\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    gl_FragDepth = depth;\n"
    "#endif\n"
    "}\n"
;

const std::string multiple_tetrahedra1 =
    "struct Shading\n"
    "{\n"
    "    float Ka; // ambient\n"
    "    float Kd; // diffuse\n"
    "    float Ks; // specular\n"
    "    float S;  // shininess\n"
    "};\n"
    "\n"
    "vec3 ShadingNone( in Shading shading, in vec3 color )\n"
    "{\n"
    "    return( color );\n"
    "}\n"
    "\n"
    "vec3 ShadingLambert( in Shading shading, in vec3 color, in vec3 L, in vec3 N )\n"
    "{\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "#endif\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "\n"
    "    return( color * ( Ia + Id ) );\n"
    "}\n"
    "\n"
    "vec3 ShadingPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 R = reflect( -L, N );\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "    float ds = pow( abs( dot( R, V ) ), shading.S );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( R, V ), 0.0 ), shading.S );\n"
    "#endif\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "vec3 ShadingBlinnPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 H = normalize( L + V );\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "    float ds = pow( abs( dot( H, N ) ), shading.S );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( H, N ), 0.0 ), shading.S );\n"
    "#endif\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "varying vec2 id;\n"
    "\n"
    "varying float depth_front;\n"
    "varying float depth_back;\n"
    "\n"
    "varying float scalar_front;\n"
    "varying float scalar_back;\n"
    "varying float distance;\n"
    "\n"
    "uniform sampler3D preintegration_texture0;\n"
    "uniform sampler2D random_texture;\n"
    "\n"
    "uniform vec2 screen_scale;\n"
    "uniform vec2 screen_scale_inv;\n"
    "uniform vec2 preintegration_scale_offset;\n"
    "\n"
    "uniform float random_texture_size_inv;\n"
    "uniform vec2 random_offset;\n"
    "\n"
    "uniform Shading shading;\n"
    "\n"
    "float distance_to_d( const in float distance )\n"
    "{\n"
    "    return( ( distance - preintegration_scale_offset.y ) / preintegration_scale_offset.x );\n"
    "}\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    vec3 lutcoord = vec3( scalar_front, scalar_back, distance );\n"
    "    vec4 lutdata = texture3D( preintegration_texture0, lutcoord );\n"
    "    if ( lutdata.a == 0.0 ) { discard; return; }\n"
    "\n"
    "    vec2 random_position = ( vec2( float( int( id.x ) * 73 ), float( int( id.y ) * 31 ) ) \n"
    "                + random_offset + gl_FragCoord.xy ) * random_texture_size_inv;\n"
    "\n"
    "    float randf = texture2D( random_texture, random_position ).x;\n"
    "    if ( randf > lutdata.a ) { discard; return; }\n"
    "\n"
    "    vec3 frag_color = lutdata.xyz / lutdata.a;\n"
    "\n"
    "    // Light position.\n"
    "    vec3 light_position = gl_LightSource[0].position.xyz;\n"
    "\n"
    "    // Light vector (L) and Normal vector (N)\n"
    "    vec3 L = normalize( light_position - position );\n"
    "    vec3 N = normalize( normal );\n"
    "\n"
    "#if   defined( ENABLE_LAMBERT_SHADING )\n"
    "    vec3 shaded_color = ShadingLambert( shading, frag_color, L, N );\n"
    "\n"
    "#elif defined( ENABLE_PHONG_SHADING )\n"
    "    vec3 V = normalize( - position );\n"
    "    vec3 shaded_color = ShadingPhong( shading, frag_color, L, N, V );\n"
    "\n"
    "#elif defined( ENABLE_BLINN_PHONG_SHADING )\n"
    "    vec3 V = normalize( - position );\n"
    "    vec3 shaded_color = ShadingBlinnPhong( shading, frag_color, L, N, V );\n"
    "\n"
    "#else // DISABLE SHADING\n"
    "    vec3 shaded_color = ShadingNone( shading, frag_color );\n"
    "#endif\n"
    "\n"
    "    gl_FragData[0] = vec4( shaded_color, 1.0 );\n"
    "    gl_FragData[1] = vec4( lutcoord, depth_front );\n"
    "    gl_FragDepth = depth_back;\n"
    "}\n"
;

const std::string multiple_tetrahedra2 =
    "struct Shading\n"
    "{\n"
    "    float Ka; // ambient\n"
    "    float Kd; // diffuse\n"
    "    float Ks; // specular\n"
    "    float S;  // shininess\n"
    "};\n"
    "\n"
    "vec3 ShadingNone( in Shading shading, in vec3 color )\n"
    "{\n"
    "    return( color );\n"
    "}\n"
    "\n"
    "vec3 ShadingLambert( in Shading shading, in vec3 color, in vec3 L, in vec3 N )\n"
    "{\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "#endif\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "\n"
    "    return( color * ( Ia + Id ) );\n"
    "}\n"
    "\n"
    "vec3 ShadingPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 R = reflect( -L, N );\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "    float ds = pow( abs( dot( R, V ) ), shading.S );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( R, V ), 0.0 ), shading.S );\n"
    "#endif\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "vec3 ShadingBlinnPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 H = normalize( L + V );\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "    float ds = pow( abs( dot( H, N ) ), shading.S );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( H, N ), 0.0 ), shading.S );\n"
    "#endif\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "varying vec2 id;\n"
    "varying float depth_front;\n"
    "varying float depth_back;\n"
    "\n"
    "varying float scalar_front;\n"
    "varying float scalar_back;\n"
    "varying float distance;\n"
    "\n"
    "uniform sampler3D preintegration_texture0;\n"
    "uniform sampler3D preintegration_texture1;\n"
    "uniform sampler2D random_texture;\n"
    "uniform sampler2D depth_texture;\n"
    "uniform sampler2D extra_texture;\n"
    "\n"
    "uniform vec2 screen_scale;\n"
    "uniform vec2 screen_scale_inv;\n"
    "uniform vec2 preintegration_scale_offset;\n"
    "\n"
    "uniform float random_texture_size_inv;\n"
    "uniform vec2 random_offset;\n"
    "\n"
    "uniform Shading shading;\n"
    "\n"
    "float distance_to_d( const in float distance )\n"
    "{\n"
    "    return( ( distance - preintegration_scale_offset.y ) / preintegration_scale_offset.x );\n"
    "}\n"
    "\n"
    "int check_overlap_case( void )\n"
    "{\n"
    "    vec2 screen_coord = gl_FragCoord.xy * screen_scale_inv;\n"
    "    vec4 extra = texture2D( extra_texture, screen_coord );\n"
    "\n"
    "    if ( extra.z == 0.0 ) return( 0 );\n"
    "\n"
    "    float v1f_d = extra.w;\n"
    "    float v1b_d = texture2D( depth_texture, screen_coord ).x;\n"
    "    float v2f_d = depth_front;\n"
    "    float v2b_d = depth_back;\n"
    "\n"
    "    if ( v1b_d >= 1.0 ) return( 0 );\n"
    "\n"
    "    if ( v2b_d < v1b_d )\n"
    "    {\n"
    "        if ( v1f_d < v2b_d )\n"
    "        {\n"
    "            if      ( v1f_d < v2f_d ) return( 1 );\n"
    "            else if ( v1f_d > v2f_d ) return( 2 );\n"
    "        }\n"
    "    }\n"
    "    else if ( v2b_d > v1b_d )\n"
    "    {\n"
    "        if ( v2f_d < v1b_d )\n"
    "        {\n"
    "            if      ( v2f_d < v1f_d ) return( 3 );\n"
    "            else if ( v2f_d > v1f_d ) return( 4 );\n"
    "        }\n"
    "    }\n"
    "\n"
    "    return( 0 );\n"
    "}\n"
    "\n"
    "vec3 calculate_shaded_color( const in vec3 frag_color )\n"
    "{\n"
    "    // Light position.\n"
    "    vec3 light_position = gl_LightSource[0].position.xyz;\n"
    "\n"
    "#if   defined( ENABLE_LAMBERT_SHADING )\n"
    "    // Light vector (L) and Normal vector (N)\n"
    "    vec3 L = normalize( light_position - position );\n"
    "    vec3 N = normalize( normal );\n"
    "    vec3 shaded_color = ShadingLambert( shading, frag_color, L, N );\n"
    "\n"
    "#elif defined( ENABLE_PHONG_SHADING )\n"
    "    // Light vector (L) and Normal vector (N)\n"
    "    vec3 L = normalize( light_position - position );\n"
    "    vec3 N = normalize( normal );\n"
    "    vec3 V = normalize( - position );\n"
    "    vec3 shaded_color = ShadingPhong( shading, frag_color, L, N, V );\n"
    "\n"
    "#elif defined( ENABLE_BLINN_PHONG_SHADING )\n"
    "    // Light vector (L) and Normal vector (N)\n"
    "    vec3 L = normalize( light_position - position );\n"
    "    vec3 N = normalize( normal );\n"
    "    vec3 V = normalize( - position );\n"
    "    vec3 shaded_color = ShadingBlinnPhong( shading, frag_color, L, N, V );\n"
    "\n"
    "#else // DISABLE SHADING\n"
    "    vec3 shaded_color = ShadingNone( shading, frag_color );\n"
    "#endif\n"
    "    return( shaded_color );\n"
    "}\n"
    "\n"
    "vec4 color_of_sf_sb_d( const in vec3 lutcoord, const in int index, const in int rand_i )\n"
    "{\n"
    "    vec4 lutdata;\n"
    "    if ( index == 0 ) lutdata = texture3D( preintegration_texture0, lutcoord );\n"
    "    else              lutdata = texture3D( preintegration_texture1, lutcoord );\n"
    "    if ( lutdata.a == 0.0 ) return( vec4( 0.0 ) );\n"
    "\n"
    "    vec2 random_position = ( vec2( float( int( id.x ) * ( 73 + rand_i ) ), float( int( id.y ) * ( 31 + rand_i ) ) ) \n"
    "                + random_offset + gl_FragCoord.xy ) * random_texture_size_inv;\n"
    "    float randf = texture2D( random_texture, random_position ).x;\n"
    "    if ( randf > lutdata.a ) return( vec4( 0.0 ) );\n"
    "\n"
    "    vec3 frag_color = lutdata.xyz / lutdata.a;\n"
    "\n"
    "    return( vec4( calculate_shaded_color( frag_color ), lutdata.a ) );\n"
    "}\n"
    "\n"
    "vec4 two_color_average( const in vec4 color1, const in vec4 color2 )\n"
    "{\n"
    "    vec3 accum_color = vec3( 0.0 );\n"
    "    int count = 0;\n"
    "    if ( color1.a > 0.0 )\n"
    "    {\n"
    "        accum_color += color1.xyz;\n"
    "        count += 1;\n"
    "    }\n"
    "    if ( color2.a > 0.0 )\n"
    "    {\n"
    "        accum_color += color2.xyz;\n"
    "        count += 1;\n"
    "    }\n"
    "\n"
    "    if      ( count == 0 ) return( vec4( 0.0 ) );\n"
    "    else if ( count == 1 ) return( vec4( accum_color, 1.0 ) );\n"
    "    return( vec4( 0.5 * accum_color, 1.0 ) );\n"
    "}\n"
    "\n"
    "void calculate_case_0( void )\n"
    "{\n"
    "    vec3 lutcoord = vec3( scalar_front, scalar_back, distance );\n"
    "    vec4 shaded_color = color_of_sf_sb_d( lutcoord, 1, 0 );\n"
    "    if ( shaded_color.a == 0.0 ) { discard; return; }\n"
    "\n"
    "    gl_FragData[0] = vec4( shaded_color.xyz, 1.0 );\n"
    "}\n"
    "\n"
    "void calculate_case_1( void )\n"
    "{\n"
    "    vec2 screen_coord = gl_FragCoord.xy * screen_scale_inv;\n"
    "    vec4 extra = texture2D( extra_texture, screen_coord );\n"
    "\n"
    "    float v1b_d = texture2D( depth_texture, screen_coord ).x;\n"
    "    float v1f_d = extra.w;\n"
    "    float v2f_d = depth_front;\n"
    "    float v2b_d = depth_back;\n"
    "\n"
    "    float v1b_to_v1f = abs( v1b_d - v1f_d );\n"
    "    float v2b_to_v2f = abs( v2b_d - v2f_d );\n"
    "\n"
    "    // 1f -> 2f : use v1\n"
    "    {\n"
    "        float ratio = ( v2f_d - v1f_d ) / v1b_to_v1f;\n"
    "        vec3 lutcoord = vec3(\n"
    "            extra.x,\n"
    "            ( 1.0 - ratio ) * extra.x + ratio * extra.y,\n"
    "            ratio * extra.z );\n"
    "        vec4 shaded_color = color_of_sf_sb_d( lutcoord, 0, 0 );\n"
    "        if ( shaded_color.a > 0.0 )\n"
    "        {\n"
    "            gl_FragData[0] = vec4( shaded_color.xyz, 1.0 );\n"
    "            return;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    // 2f -> 2b : use v1 + v2\n"
    "    {\n"
    "        float ratio1 = ( v2f_d - v1f_d ) / v1b_to_v1f;\n"
    "        float ratio2 = ( v2b_d - v1f_d ) / v1b_to_v1f;\n"
    "        vec3 lutcoord1 = vec3(\n"
    "            ( 1.0 - ratio1 ) * extra.x + ratio1 * extra.y,\n"
    "            ( 1.0 - ratio2 ) * extra.x + ratio2 * extra.y,\n"
    "            distance );\n"
    "\n"
    "        vec3 lutcoord2 = vec3( scalar_front, scalar_back, distance );\n"
    "\n"
    "        vec4 shaded_color1 = color_of_sf_sb_d( lutcoord1, 0, 1 );\n"
    "        vec4 shaded_color2 = color_of_sf_sb_d( lutcoord2, 1, 2 );\n"
    "        vec4 shaded_color = two_color_average( shaded_color1, shaded_color2 );\n"
    "        if ( shaded_color.a > 0.0 )\n"
    "        {\n"
    "            gl_FragData[0] = vec4( shaded_color.xyz, 1.0 );\n"
    "            return;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    // 2b -> 1b : use v1\n"
    "    {\n"
    "        float ratio = ( v2b_d - v1f_d ) / v1b_to_v1f;\n"
    "        vec3 lutcoord = vec3(\n"
    "            ( 1.0 - ratio ) * extra.x + ratio * extra.y,\n"
    "            extra.y,\n"
    "            ( 1.0 - ratio ) * extra.z );\n"
    "        vec4 shaded_color = color_of_sf_sb_d( lutcoord, 0, 3 );\n"
    "        if ( shaded_color.a > 0.0 )\n"
    "        {\n"
    "            gl_FragData[0] = vec4( shaded_color.xyz, 1.0 );\n"
    "            return;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    discard;\n"
    "}\n"
    "\n"
    "void calculate_case_2( void )\n"
    "{\n"
    "    vec2 screen_coord = gl_FragCoord.xy * screen_scale_inv;\n"
    "    vec4 extra = texture2D( extra_texture, screen_coord );\n"
    "\n"
    "    float v1b_d = texture2D( depth_texture, screen_coord ).x;\n"
    "    float v1f_d = extra.w;\n"
    "    float v2f_d = depth_front;\n"
    "    float v2b_d = depth_back;\n"
    "\n"
    "    float v1b_to_v1f = abs( v1b_d - v1f_d );\n"
    "    float v2b_to_v2f = abs( v2b_d - v2f_d );\n"
    "\n"
    "    // 2f -> 1f : use v2\n"
    "    {\n"
    "        float ratio = ( v1f_d - v2f_d ) / v2b_to_v2f;\n"
    "        vec3 lutcoord = vec3(\n"
    "            scalar_front,\n"
    "            ( 1.0 - ratio ) * scalar_front + ratio * scalar_back,\n"
    "            ratio * distance );\n"
    "        vec4 shaded_color = color_of_sf_sb_d( lutcoord, 1, 0 );\n"
    "        if ( shaded_color.a > 0.0 )\n"
    "        {\n"
    "            gl_FragData[0] = vec4( shaded_color.xyz, 1.0 );\n"
    "            return;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    // 1f -> 2b : use v1 + v2\n"
    "    {\n"
    "        float ratio1 = ( v2b_d - v1f_d ) / v1b_to_v1f;\n"
    "        vec3 lutcoord1 = vec3(\n"
    "            extra.x,\n"
    "            ( 1.0 - ratio1 ) * extra.x + ratio1 * extra.y,\n"
    "            ratio1 * extra.z );\n"
    "\n"
    "        float ratio2 = ( v1f_d - v2f_d ) / v2b_to_v2f;\n"
    "        vec3 lutcoord2 = vec3(\n"
    "            ( 1.0 - ratio2 ) * scalar_front + ratio2 * scalar_back,\n"
    "            scalar_back, ratio1 * extra.z );\n"
    "\n"
    "        vec4 shaded_color1 = color_of_sf_sb_d( lutcoord1, 0, 1 );\n"
    "        vec4 shaded_color2 = color_of_sf_sb_d( lutcoord2, 1, 2 );\n"
    "        vec4 shaded_color = two_color_average( shaded_color1, shaded_color2 );\n"
    "        if ( shaded_color.a > 0.0 )\n"
    "        {\n"
    "            gl_FragData[0] = vec4( shaded_color.xyz, 1.0 );\n"
    "            return;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    // 2b -> 1b : use v1\n"
    "    {\n"
    "        float ratio = ( v2b_d - v1f_d ) / v1b_to_v1f;\n"
    "        vec3 lutcoord = vec3(\n"
    "            ( 1.0 - ratio ) * extra.x + ratio * extra.y,\n"
    "            extra.y,\n"
    "            ( 1.0 - ratio ) * extra.z );\n"
    "        vec4 shaded_color = color_of_sf_sb_d( lutcoord, 0, 3 );\n"
    "        if ( shaded_color.a > 0.0 )\n"
    "        {\n"
    "            gl_FragData[0] = vec4( shaded_color.xyz, 1.0 );\n"
    "            return;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    discard;\n"
    "}\n"
    "\n"
    "void calculate_case_3( void )\n"
    "{\n"
    "    vec2 screen_coord = gl_FragCoord.xy * screen_scale_inv;\n"
    "    vec4 extra = texture2D( extra_texture, screen_coord );\n"
    "\n"
    "    float v1b_d = texture2D( depth_texture, screen_coord ).x;\n"
    "    float v1f_d = extra.w;\n"
    "    float v2f_d = depth_front;\n"
    "    float v2b_d = depth_back;\n"
    "\n"
    "    float v1b_to_v1f = abs( v1b_d - v1f_d );\n"
    "    float v2b_to_v2f = abs( v2b_d - v2f_d );\n"
    "\n"
    "    // 2f -> 1f : use v2\n"
    "    {\n"
    "        float ratio = ( v1f_d - v2f_d ) / v2b_to_v2f;\n"
    "        vec3 lutcoord = vec3(\n"
    "            scalar_front,\n"
    "            ( 1.0 - ratio ) * scalar_front + ratio * scalar_back,\n"
    "            ratio * distance );\n"
    "        vec4 shaded_color = color_of_sf_sb_d( lutcoord, 1, 0 );\n"
    "        if ( shaded_color.a > 0.0 )\n"
    "        {\n"
    "            gl_FragData[0] = vec4( shaded_color.xyz, 1.0 );\n"
    "            return;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    // 1f -> 1b : use v1 + v2\n"
    "    {\n"
    "        vec3 lutcoord1 = extra.xyz;\n"
    "\n"
    "        float ratio1 = ( v1f_d - v2f_d ) / v2b_to_v2f;\n"
    "        float ratio2 = ( v1b_d - v2f_d ) / v2b_to_v2f;\n"
    "        vec3 lutcoord2 = vec3(\n"
    "            ( 1.0 - ratio1 ) * scalar_front + ratio1 * scalar_back,\n"
    "            ( 1.0 - ratio2 ) * scalar_front + ratio2 * scalar_back,\n"
    "            extra.z );\n"
    "\n"
    "        vec4 shaded_color1 = color_of_sf_sb_d( lutcoord1, 0, 1 );\n"
    "        vec4 shaded_color2 = color_of_sf_sb_d( lutcoord2, 1, 2 );\n"
    "        vec4 shaded_color = two_color_average( shaded_color1, shaded_color2 );\n"
    "        if ( shaded_color.a > 0.0 )\n"
    "        {\n"
    "            gl_FragData[0] = vec4( shaded_color.xyz, 1.0 );\n"
    "            return;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    // 1b -> 2b : use v2\n"
    "    {\n"
    "        float ratio = ( v1b_d - v2f_d ) / v2b_to_v2f;\n"
    "        vec3 lutcoord = vec3(\n"
    "            ( 1.0 - ratio ) * scalar_front + ratio * scalar_back,\n"
    "            scalar_back,\n"
    "            ( 1.0 - ratio ) * distance );\n"
    "        vec4 shaded_color = color_of_sf_sb_d( lutcoord, 1, 3 );\n"
    "        if ( shaded_color.a > 0.0 )\n"
    "        {\n"
    "            gl_FragData[0] = vec4( shaded_color.xyz, 1.0 );\n"
    "            return;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    discard;\n"
    "}\n"
    "\n"
    "void calculate_case_4( void )\n"
    "{\n"
    "    vec2 screen_coord = gl_FragCoord.xy * screen_scale_inv;\n"
    "    vec4 extra = texture2D( extra_texture, screen_coord );\n"
    "\n"
    "    float v1b_d = texture2D( depth_texture, screen_coord ).x;\n"
    "    float v1f_d = extra.w;\n"
    "    float v2f_d = depth_front;\n"
    "    float v2b_d = depth_back;\n"
    "\n"
    "    float v1b_to_v1f = abs( v1b_d - v1f_d );\n"
    "    float v2b_to_v2f = abs( v2b_d - v2f_d );\n"
    "\n"
    "    // 1f -> 2f : use v1\n"
    "    {\n"
    "        float ratio = ( v2f_d - v1f_d ) / v1b_to_v1f;\n"
    "        vec3 lutcoord = vec3(\n"
    "            extra.x,\n"
    "            ( 1.0 - ratio ) * extra.x + ratio * extra.y,\n"
    "            ratio * extra.z );\n"
    "        vec4 shaded_color = color_of_sf_sb_d( lutcoord, 0, 0 );\n"
    "        if ( shaded_color.a > 0.0 )\n"
    "        {\n"
    "            gl_FragData[0] = vec4( shaded_color.xyz, 1.0 );\n"
    "            return;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    // 2f -> 1b : use v1 + v2\n"
    "    {\n"
    "        float ratio1 = ( v2f_d - v1f_d ) / v1b_to_v1f;\n"
    "        vec3 lutcoord1 = vec3(\n"
    "            ( 1.0 - ratio1 ) * extra.x + ratio1 * extra.y,\n"
    "            extra.y,\n"
    "            ( 1.0 - ratio1 ) * extra.z );\n"
    "\n"
    "        float ratio2 = ( v1b_d - v2f_d ) / v2b_to_v2f;\n"
    "        vec3 lutcoord2 = vec3(\n"
    "            scalar_front,\n"
    "            ( 1.0 - ratio2 ) * scalar_front + ratio2 * scalar_back,\n"
    "            ( 1.0 - ratio1 ) * extra.z );\n"
    "\n"
    "        vec4 shaded_color1 = color_of_sf_sb_d( lutcoord1, 0, 5 );\n"
    "        vec4 shaded_color2 = color_of_sf_sb_d( lutcoord2, 1, 10 );\n"
    "        vec4 shaded_color = two_color_average( shaded_color1, shaded_color2 );\n"
    "        if ( shaded_color.a > 0.0 )\n"
    "        {\n"
    "            gl_FragData[0] = vec4( shaded_color.xyz, 1.0 );\n"
    "            return;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    // 1b -> 2b : use v2\n"
    "    {\n"
    "        float ratio = ( v1b_d - v2f_d ) / v2b_to_v2f;\n"
    "        vec3 lutcoord = vec3(\n"
    "            ( 1.0 - ratio ) * scalar_front + ratio * scalar_back,\n"
    "            scalar_back,\n"
    "            ( 1.0 - ratio ) * distance );\n"
    "        vec4 shaded_color = color_of_sf_sb_d( lutcoord, 1, 15 );\n"
    "        if ( shaded_color.a > 0.0 )\n"
    "        {\n"
    "            gl_FragData[0] = vec4( shaded_color.xyz, 1.0 );\n"
    "            return;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    discard;\n"
    "}\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_FragDepth = depth_front;\n"
    "    gl_FragData[1] = vec4( 0.0, 0.0, 0.0, 1.0 );\n"
    "\n"
    "    int overlap = check_overlap_case();\n"
    "\n"
    "    if      ( overlap == 0 ) { calculate_case_0(); }\n"
    "    else if ( overlap == 1 ) { calculate_case_1(); }\n"
    "    else if ( overlap == 2 ) { calculate_case_2(); }\n"
    "    //else if ( overlap == 2 ) { gl_FragData[0] = vec4( 0.0, 1.0, 0.0, 1.0 ); }\n"
    "    else if ( overlap == 3 ) { calculate_case_3(); }\n"
    "    //else if ( overlap == 3 ) { gl_FragData[0] = vec4( 0.0, 0.0, 1.0, 1.0 ); }\n"
    "    else if ( overlap == 4 ) { calculate_case_4(); }\n"
    "    //else if ( overlap == 4 ) { gl_FragData[0] = vec4( 1.0, 1.0, 0.0, 1.0 ); }\n"
    "\n"
    "    //if      ( overlap == 1 ) { gl_FragData[0] = vec4( 1.0, 0.0, 0.0, 1.0 ); }\n"
    "    //else if ( overlap == 2 ) { gl_FragData[0] = vec4( 0.0, 1.0, 0.0, 1.0 ); }\n"
    "    //else if ( overlap == 3 ) { gl_FragData[0] = vec4( 0.0, 0.0, 1.0, 1.0 ); }\n"
    "    //else if ( overlap == 4 ) { gl_FragData[0] = vec4( 1.0, 1.0, 0.0, 1.0 ); }\n"
    "\n"
    "}\n"
;

const std::string multivariate_tetrahedra =
    "struct Shading\n"
    "{\n"
    "    float Ka; // ambient\n"
    "    float Kd; // diffuse\n"
    "    float Ks; // specular\n"
    "    float S;  // shininess\n"
    "};\n"
    "\n"
    "vec3 ShadingNone( in Shading shading, in vec3 color )\n"
    "{\n"
    "    return( color );\n"
    "}\n"
    "\n"
    "vec3 ShadingLambert( in Shading shading, in vec3 color, in vec3 L, in vec3 N )\n"
    "{\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "#endif\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "\n"
    "    return( color * ( Ia + Id ) );\n"
    "}\n"
    "\n"
    "vec3 ShadingPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 R = reflect( -L, N );\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "    float ds = pow( abs( dot( R, V ) ), shading.S );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( R, V ), 0.0 ), shading.S );\n"
    "#endif\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "vec3 ShadingBlinnPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 H = normalize( L + V );\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "    float ds = pow( abs( dot( H, N ) ), shading.S );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( H, N ), 0.0 ), shading.S );\n"
    "#endif\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "varying vec2 id;\n"
    "\n"
    "varying vec2 scalar_front;\n"
    "varying vec2 scalar_back;\n"
    "varying float distance;\n"
    "\n"
    "uniform sampler3D preintegration_texture0;\n"
    "uniform sampler3D preintegration_texture1;\n"
    "uniform sampler2D random_texture;\n"
    "\n"
    "uniform vec2 screen_scale;\n"
    "uniform vec2 screen_scale_inv;\n"
    "uniform vec2 preintegration_scale_offset;\n"
    "\n"
    "uniform float random_texture_size_inv;\n"
    "uniform vec2 random_offset;\n"
    "\n"
    "uniform int start_volume;\n"
    "uniform int end_volume;\n"
    "\n"
    "uniform Shading shading;\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    int accept = 0;\n"
    "    vec3 accum_color = vec3( 0.0, 0.0, 0.0 );\n"
    "\n"
    "    for ( int i = start_volume; i < end_volume; i++ )\n"
    "    {\n"
    "        vec4 lutdata;\n"
    "        if ( i == 0 )\n"
    "        {\n"
    "            vec3 lutcoord = vec3( scalar_front.x, scalar_back.x, distance );\n"
    "            lutdata = texture3D( preintegration_texture0, lutcoord );\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            vec3 lutcoord = vec3( scalar_front.y, scalar_back.y, distance );\n"
    "            lutdata = texture3D( preintegration_texture1, lutcoord );\n"
    "        }\n"
    "\n"
    "        if ( lutdata.a == 0.0 ) continue;\n"
    "\n"
    "        vec2 random_position = ( vec2( float( int( id.x ) * 73 ), float( int( id.y ) * 31 ) ) \n"
    "                    + ( 1.0 + float(i) * 2.6 ) * random_offset + gl_FragCoord.xy ) * random_texture_size_inv;\n"
    "\n"
    "        float randf = texture2D( random_texture, random_position ).x;\n"
    "        if ( randf > lutdata.a ) continue;\n"
    "\n"
    "        vec3 frag_color = lutdata.xyz / lutdata.a;\n"
    "\n"
    "        // Light position.\n"
    "        vec3 light_position = gl_LightSource[0].position.xyz;\n"
    "\n"
    "        // Light vector (L) and Normal vector (N)\n"
    "        vec3 L = normalize( light_position - position );\n"
    "        vec3 N = normalize( normal );\n"
    "\n"
    "#if   defined( ENABLE_LAMBERT_SHADING )\n"
    "        vec3 shaded_color = ShadingLambert( shading, frag_color, L, N );\n"
    "\n"
    "#elif defined( ENABLE_PHONG_SHADING )\n"
    "        vec3 V = normalize( - position );\n"
    "        vec3 shaded_color = ShadingPhong( shading, frag_color, L, N, V );\n"
    "\n"
    "#elif defined( ENABLE_BLINN_PHONG_SHADING )\n"
    "        vec3 V = normalize( - position );\n"
    "        vec3 shaded_color = ShadingBlinnPhong( shading, frag_color, L, N, V );\n"
    "\n"
    "#else // DISABLE SHADING\n"
    "        vec3 shaded_color = ShadingNone( shading, frag_color );\n"
    "#endif\n"
    "\n"
    "        accept += 1;\n"
    "        accum_color += shaded_color;\n"
    "    }\n"
    "\n"
    "    if ( accept == 0 ) { discard; return; }\n"
    "    else if ( accept == 1 )\n"
    "    {\n"
    "        gl_FragColor = vec4( accum_color, 1.0 );\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        gl_FragColor = vec4( 0.5 * accum_color, 1.0 );\n"
    "    }\n"
    "}\n"
;

const std::string point =
    "struct Shading\n"
    "{\n"
    "    float Ka; // ambient\n"
    "    float Kd; // diffuse\n"
    "    float Ks; // specular\n"
    "    float S;  // shininess\n"
    "};\n"
    "\n"
    "vec3 ShadingNone( in Shading shading, in vec3 color )\n"
    "{\n"
    "    return( color );\n"
    "}\n"
    "\n"
    "vec3 ShadingLambert( in Shading shading, in vec3 color, in vec3 L, in vec3 N )\n"
    "{\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "#endif\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "\n"
    "    return( color * ( Ia + Id ) );\n"
    "}\n"
    "\n"
    "vec3 ShadingPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 R = reflect( -L, N );\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "    float ds = pow( abs( dot( R, V ) ), shading.S );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( R, V ), 0.0 ), shading.S );\n"
    "#endif\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "vec3 ShadingBlinnPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 H = normalize( L + V );\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "    float ds = pow( abs( dot( H, N ) ), shading.S );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( H, N ), 0.0 ), shading.S );\n"
    "#endif\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "varying vec3  position;\n"
    "varying vec3  normal;\n"
    "varying vec2  center;\n"
    "varying float radius;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "varying float depth;\n"
    "#endif\n"
    "\n"
    "uniform Shading shading;\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    // Discard a pixel outside circle.\n"
    "    if ( radius > 0.0 )\n"
    "    {\n"
    "        if( distance( gl_FragCoord.xy, center ) > radius ) discard;\n"
    "    }\n"
    "\n"
    "    // Light position.\n"
    "    vec3 light_position = gl_LightSource[0].position.xyz;\n"
    "\n"
    "    // Light vector (L) and Normal vector (N)\n"
    "    vec3 L = normalize( light_position - position );\n"
    "    vec3 N = normalize( normal );\n"
    "\n"
    "#if   defined( ENABLE_LAMBERT_SHADING )\n"
    "    vec3 shaded_color = ShadingLambert( shading, gl_Color.xyz, L, N );\n"
    "\n"
    "#elif defined( ENABLE_PHONG_SHADING )\n"
    "    vec3 V = normalize( -position );\n"
    "    vec3 shaded_color = ShadingPhong( shading, gl_Color.xyz, L, N, V );\n"
    "\n"
    "#elif defined( ENABLE_BLINN_PHONG_SHADING )\n"
    "    vec3 V = normalize( -position );\n"
    "    vec3 shaded_color = ShadingBlinnPhong( shading, gl_Color.xyz, L, N, V );\n"
    "\n"
    "#else // DISABLE SHADING\n"
    "    vec3 shaded_color = ShadingNone( shading, gl_Color.xyz );\n"
    "#endif\n"
    "\n"
    "    gl_FragColor.xyz = shaded_color;\n"
    "    gl_FragColor.w = 1.0;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    gl_FragDepth = depth;\n"
    "#endif\n"
    "}\n"
;

const std::string polygon =
    "struct Shading\n"
    "{\n"
    "    float Ka; // ambient\n"
    "    float Kd; // diffuse\n"
    "    float Ks; // specular\n"
    "    float S;  // shininess\n"
    "};\n"
    "\n"
    "vec3 ShadingNone( in Shading shading, in vec3 color )\n"
    "{\n"
    "    return( color );\n"
    "}\n"
    "\n"
    "vec3 ShadingLambert( in Shading shading, in vec3 color, in vec3 L, in vec3 N )\n"
    "{\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "#endif\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "\n"
    "    return( color * ( Ia + Id ) );\n"
    "}\n"
    "\n"
    "vec3 ShadingPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 R = reflect( -L, N );\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "    float ds = pow( abs( dot( R, V ) ), shading.S );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( R, V ), 0.0 ), shading.S );\n"
    "#endif\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "vec3 ShadingBlinnPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 H = normalize( L + V );\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "    float ds = pow( abs( dot( H, N ) ), shading.S );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( H, N ), 0.0 ), shading.S );\n"
    "#endif\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "varying vec2 id;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "varying float depth;\n"
    "#endif\n"
    "\n"
    "uniform sampler2D random_texture;\n"
    "\n"
    "uniform vec2 screen_scale;\n"
    "uniform vec2 screen_scale_inv;\n"
    "\n"
    "uniform float random_texture_size_inv;\n"
    "uniform vec2 random_offset;\n"
    "\n"
    "uniform Shading shading;\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    if ( gl_Color.a == 0.0 ) { discard; return; }\n"
    "\n"
    "    if ( gl_Color.a < 0.99999 )\n"
    "    {\n"
    "        vec2 random_position = ( vec2( float( int( id.x ) * 73 ), float( int( id.y ) * 31 ) ) \n"
    "                    + random_offset + gl_FragCoord.xy ) * random_texture_size_inv;\n"
    "\n"
    "        float randf = texture2D( random_texture, random_position ).a;\n"
    "        if ( randf > gl_Color.a ) { discard; return; }\n"
    "    }\n"
    "\n"
    "    vec3 frag_color = gl_Color.rgb;\n"
    "\n"
    "    // Light position.\n"
    "    vec3 light_position = gl_LightSource[0].position.xyz;\n"
    "\n"
    "    // Light vector (L) and Normal vector (N)\n"
    "    vec3 L = normalize( light_position - position );\n"
    "    vec3 N = normalize( normal );\n"
    "\n"
    "#if   defined( ENABLE_LAMBERT_SHADING )\n"
    "    vec3 shaded_color = ShadingLambert( shading, frag_color, L, N );\n"
    "\n"
    "#elif defined( ENABLE_PHONG_SHADING )\n"
    "    vec3 V = normalize( -position );\n"
    "    vec3 shaded_color = ShadingPhong( shading, frag_color, L, N, V );\n"
    "\n"
    "#elif defined( ENABLE_BLINN_PHONG_SHADING )\n"
    "    vec3 V = normalize( -position );\n"
    "    vec3 shaded_color = ShadingBlinnPhong( shading, frag_color, L, N, V );\n"
    "\n"
    "#else // DISABLE SHADING\n"
    "    vec3 shaded_color = ShadingNone( shading, frag_color );\n"
    "#endif\n"
    "\n"
    "    gl_FragColor = vec4( shaded_color, 1.0 );\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    gl_FragDepth = depth;\n"
    "#endif\n"
    "}\n"
;

const std::string tetrahedra =
    "struct Shading\n"
    "{\n"
    "    float Ka; // ambient\n"
    "    float Kd; // diffuse\n"
    "    float Ks; // specular\n"
    "    float S;  // shininess\n"
    "};\n"
    "\n"
    "vec3 ShadingNone( in Shading shading, in vec3 color )\n"
    "{\n"
    "    return( color );\n"
    "}\n"
    "\n"
    "vec3 ShadingLambert( in Shading shading, in vec3 color, in vec3 L, in vec3 N )\n"
    "{\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "#endif\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "\n"
    "    return( color * ( Ia + Id ) );\n"
    "}\n"
    "\n"
    "vec3 ShadingPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 R = reflect( -L, N );\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "    float ds = pow( abs( dot( R, V ) ), shading.S );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( R, V ), 0.0 ), shading.S );\n"
    "#endif\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "vec3 ShadingBlinnPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 H = normalize( L + V );\n"
    "#if defined( ENABLE_TWO_SIDE_LIGHTING )\n"
    "    float dd = abs( dot( N, L ) );\n"
    "    float ds = pow( abs( dot( H, N ) ), shading.S );\n"
    "#else\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( H, N ), 0.0 ), shading.S );\n"
    "#endif\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "varying vec2 id;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "varying float depth_front;\n"
    "varying float depth_back;\n"
    "#endif\n"
    "\n"
    "varying float scalar_front;\n"
    "varying float scalar_back;\n"
    "varying float distance;\n"
    "\n"
    "uniform sampler3D preintegration_texture;\n"
    "uniform sampler2D random_texture;\n"
    "\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "uniform sampler2D depth_texture;\n"
    "#endif\n"
    "\n"
    "uniform vec2 screen_scale;\n"
    "uniform vec2 screen_scale_inv;\n"
    "uniform vec2 preintegration_scale_offset;\n"
    "\n"
    "uniform float random_texture_size_inv;\n"
    "uniform vec2 random_offset;\n"
    "\n"
    "uniform Shading shading;\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    vec4 lutdata;\n"
    "    vec2 screen_coord = gl_FragCoord.xy * screen_scale_inv;\n"
    "    float geom_d = texture2D( depth_texture, screen_coord ).x;\n"
    "    if ( geom_d < 1.0 && depth_front <= geom_d && geom_d <= depth_back )\n"
    "    {\n"
    "        float ratio = ( geom_d - depth_front ) / ( depth_back - depth_front );\n"
    "        vec3 lutcoord = vec3( scalar_front, ( 1.0 - ratio ) * scalar_front + ratio * scalar_back, ratio * distance );\n"
    "        lutdata = texture3D( preintegration_texture, lutcoord );\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        vec3 lutcoord = vec3( scalar_front, scalar_back, distance );\n"
    "        lutdata = texture3D( preintegration_texture, lutcoord );\n"
    "    }\n"
    "#else\n"
    "    vec3 lutcoord = vec3( scalar_front, scalar_back, distance );\n"
    "    vec4 lutdata = texture3D( preintegration_texture, lutcoord );\n"
    "#endif\n"
    "    if ( lutdata.a == 0.0 ) { discard; return; }\n"
    "\n"
    "    vec2 random_position = ( vec2( float( int( id.x ) * 73 ), float( int( id.y ) * 31 ) ) \n"
    "                + random_offset + gl_FragCoord.xy ) * random_texture_size_inv;\n"
    "\n"
    "    float randf = texture2D( random_texture, random_position ).x;\n"
    "    if ( randf > lutdata.a ) { discard; return; }\n"
    "\n"
    "    vec3 frag_color = lutdata.xyz / lutdata.a;\n"
    "\n"
    "    // Light position.\n"
    "    vec3 light_position = gl_LightSource[0].position.xyz;\n"
    "\n"
    "    // Light vector (L) and Normal vector (N)\n"
    "    vec3 L = normalize( light_position - position );\n"
    "    vec3 N = normalize( normal );\n"
    "\n"
    "#if   defined( ENABLE_LAMBERT_SHADING )\n"
    "    vec3 shaded_color = ShadingLambert( shading, frag_color, L, N );\n"
    "\n"
    "#elif defined( ENABLE_PHONG_SHADING )\n"
    "    vec3 V = normalize( - position );\n"
    "    vec3 shaded_color = ShadingPhong( shading, frag_color, L, N, V );\n"
    "\n"
    "#elif defined( ENABLE_BLINN_PHONG_SHADING )\n"
    "    vec3 V = normalize( - position );\n"
    "    vec3 shaded_color = ShadingBlinnPhong( shading, frag_color, L, N, V );\n"
    "\n"
    "#else // DISABLE SHADING\n"
    "    vec3 shaded_color = ShadingNone( shading, frag_color );\n"
    "#endif\n"
    "\n"
    "    gl_FragColor = vec4( shaded_color, 1.0 );\n"
    "#if defined( ENABLE_EXACT_DEPTH_TESTING )\n"
    "    gl_FragDepth = depth_front;\n"
    "#endif\n"
    "}\n"
;

} // end of namespace Fragment

} // end of namespace StochasticRenderingEngine

} } } // end of namespace kvs, glew, glsl

#endif // KVS__GLEW__GLSL__StochasticRenderingEngine_H_INCLUDE
